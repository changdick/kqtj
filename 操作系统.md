# 操作系统
## 调度算法整理
### 1 进程调度算法
CPU调度涉及的时间指标：周转时间、等待时间、响应时间  
周转时间：从作业到达到完成  
等待时间：在就绪态等待的总时间
响应时间：从作业到达到第一次运行的时间

具体调度算法：  
FCFS：先到先服务，按照到达时间来排序  
SJF： 短作业优先，按照作业运行需要的时间
RR（轮询调度）：时间片轮流  
多队列反馈    
彩票调度  
其中，SJF还有可抢占的版本，也叫做最短剩余作业优先。 

#### 时间片轮转调度注意
轮流调度的进程有一个队列，队列是按照fcfs的顺序来排的，一个进程结束后，应当进入队列末尾。队列长什么样要注意。不能简单地认为几个进程一定12341234这样轮流。当4来的比较晚，可能变成23142314的轮流。

### 2 内存页调换算法
内存页调换算法有：先进先出FIFO、最佳置换算法、LRU、CLOCK算法  
FIFO：按照页面进入的顺序换出  
最佳置换算法：理论上的，实际上实现不了。每次选择未来最远使用的换出。  
LRU：选择最近最少使用的，可以用时间戳、栈实现  
时钟置换算法：维护访问位。改进版还考虑修改位  

### 3 磁盘调度算法
FCFS：先到先服务，按照请求顺序移动磁头，平均寻找长度最大，公平。  
SSTF：最短寻找时间优先，总是处理最近的请求。两端的请求会饥饿。  
SCAN算法（扫描、电梯）：延某个方向一定会到头才折回。  
C-SCAN：循环扫描，一定是单向扫描读取，到一端后，直接移动到另一端。
C-LOOK：在C-SCAN的基础上，不会走到头，而是会看是否是该方向最后一个请求，如果是的话，处理后就移动到另一端的**请求**(区别于C-SCAN和SCAN是移动到磁道头)上。  
LOOK调度：SCAN的LOOK版，不会走到头才折返。C-LOOK是C-SCAN的look版。

### 4 连续内存分配中的分配方案
有首次适配、最佳适配、最差适配  

## 进程与线程
  
### 进程
进程控制块：PCB  ，进程的动态特征  
pcb中保存进程的进程描述信息，进程控制和管理信息，资源分配清单，处理器相关信息  
进程 = PCB + 程序 + 数据  

进程的特点：动态性，并发性，独立性，异步性，结构性。

进程是**资源分配**的基本单位。
#### 进程的状态
进程的三种状态：就绪态、运行态、阻塞态  
需要了解三种状态的相互转换。就绪态被调度到就变成运行态，运行到时间片结束回到就绪态，运行态如果需要等IO就进入阻塞态，阻塞态IO完成了进入就绪态。**阻塞态无法直接进入运行态**。   

如果按照五个状态来分，可以新增创建和终止两个状态。创建了PCB，还没有进入就绪队列，算创建状态。进程结束了但还没有回收资源，算终止状态。
#### 进程控制
进程的创建：进程是父进程创建的，用fork调用。
fork():调用后创建子进程，fork调用一次返回两次，给父进程返回子进程pid，给此进程返回0。  

进程终止：进程终止包括三种情况，正常结束，异常结束，外界干预终止。exit调用用于终止一个进程。exit被称为调用一次，永不返回。比如exit(0)读入一个整数，这个整数会给到父进程，父进程wait类的调用会收到这个数。  

进程阻塞和唤醒：阻塞是进程自身的一种主动行为，阻塞的原因是期待的事情没有发生。 

##### 进程图和fork次数计算
画进程图表示有fork的程序运行的过程，分析结果可能有哪些。  

#### 子进程回收
两个概念：僵尸进程、孤儿进程。  
如果一个进程exit，父进程没有用wait来回收他，这个子进程是僵尸进程，由init进程回收。父进程死了之后，init会回收僵尸进程。

如果父进程结束了，子进程还在运行，这个子进程是孤儿进程，那么init会收养这个子进程，子进程的父进程就变成了init，必须显示杀死，由init回收。  

#### 进程通信
进程之间通信的方式：共享存储（共享内存），消息传递，管道。  
消息传递：分为直接通信和间接，直接通信通过消息缓冲队列，间接通过信箱，信箱是一个中间实体。  
管道：半双工的，意思是单向流动，一个管道只能一方写另一方读。管道其实是一个共享文件。管道必须提供三方面协调能力：互斥，同步，确定对方存在。

### 异常控制流
异常有4种，按照同步异步可以分2类，异步的就是中断，同步的有陷阱，故障，终止。  
陷阱：有意的异常，回到下一条指令继续运行。例如系统调用  
故障：无意的，可能可以恢复并回到出故障的指令重新运行，也可能不可恢复终止了。例如缺页，除0，浮点异常  
终止：无意的，不可恢复，只能终止当前程序。例如奇偶校验错误  
中断：外部事件引发，通过cpu中断引脚，回到下一条指令。  

### 线程
线程是**调度**的基本单位。进程中可以有多个线程，共享进程的资源。  
线程有栈和寄存器。  

#### 用户级线程 和内核级线程
用户级线程：完全由用户程序完成线程调度，内核意识不到线程的存在。也就是，内核只负责进程调度，不负责进程内线程的调度。某个线程阻塞，意味着这个进程阻塞。因此不需要内核支持。同一进程用户级线程的切换开销比内核级线程小。    

如果要让内核帮助线程调度，得用内核级线程。  

内核级线程：由操作系统来支持和管理。  


##### 线程模型
为了让操作系统进行用户线程调度，用户级线程得映射到内核级线程，就有了三种连接模型。  
1. 多对一模型
多个用户线程对应一个内核级线程，如果其中一个用户线程阻塞，实际上所有用户线程，也就是整个进程阻塞。实际上内核调度的是那个内核级线程，这些线程不能够多核并行。  
2. 一对一模型
每个用户线程对应一个内核级线程，并发能力强，但是内核线程太多，开销大。  
3. 多对多模型
多个用户线程，对应多个内核线程，但是用户线程更多。克服了多对一模型并发度低的缺点，一对一模型开销大的缺点。  

#### POSIX线程库
```c
// 线程的演示文件

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>  // 线程相关的头文件

#define NUM_THREADS 5  // 定义线程数量

pthread_t threads[NUM_THREADS];  // 定义线程数组

// 任务函数原型声明
void * hello(void * vargp); 

char **ptr; // 定义一个字符串数组，用于传递msg消息给线程
int main() {
    int i;

    // 定义每个线程要打印的字符串，这个信息要通过传参方式传递给线程。通过全局变量传递
    char *msg[NUM_THREADS] = {
        "Hello from A",
        "Hello from B",
        "Hello from C",
        "Hello from D",
        "Hello from E"
    };
    ptr = msg;   // 全局变量传递参数, 线程可直接访问全局变量

    int taskid[NUM_THREADS];  // 定义线程 ID 数组, 这个也通过传参，但是通过pthread_create函数的参数传递
    for ( i = 0; i < NUM_THREADS; i++) {
        taskid[i] = i;   // 定义线程号

        // 创建线程
        // 创建线程时可以传一个参数给线程，这个参数是void*类型，可以传任意类型的参数
        // 这一句在创建线程时，第四个参数要求void*类型，但是直接传入int*类型是可以的
        // taskid+i 完全等价于 &taskid[i] 
        pthread_create(threads + i, NULL, hello, taskid + i); // 创建线程


        printf("Thread %d created, tid=%lu\n", i, threads[i]);

        // 如果开启了join，一定会依次创建并输出。如果没有开启顺序是随机的
        // pthread_join(threads[i], NULL);  // 等待线程结束
    }
    
    pthread_exit(NULL);  // 主线程退出


}

// 定义线程要执行的任务函数
void * hello(void * vargp) {
    // 这里接收到的参数一定是void*类型，但是可以通过强制类型转换得到原来的类型。
    // 为了获取到myid，先把void *类型强转回到int *类型，然后再对它解引用得到int类型的值
    int myid = *((int *) vargp);    // 获取线程 ID
    static int count = 0;

    printf("Hello from No. %d thread, tid=%lu, count=%d \n", myid, threads[myid], count++);
    printf("%s\n", ptr[myid]);  // 打印传递的消息

    pthread_exit(NULL);  // 退出线程

    // return NULL;  // 返回空指针。 返回值要求void*类型，传NULL即空指针是合理的
}

/*
    1. 线程的任务函数
    创建线程的时候读入的线程任务函数，参数只有一个是void *类型， 返回值也定义成void *类型必须是这样的。
    2. 线程的创建
    线程创建读入的参数依次是：线程id的地址，线程属性（NULL表示默认），线程任务函数的指针（直接传入函数名字就是了），线程函数的参数 必须是void * 类型
    在创建线程时，尽管参数要求void*类型，但是直接传入int*类型是可以的

    3. 线程传递参数
    这个文件值得研究的参数有：ptr，count，msg，i，myid
    ptr是全局变量，对主线程和子线程都可见，在内存中只有一个实例
    count是子线程hello函数的静态变量，主线程不可见，但是hello创建的子线程都可见并且共享。在内存中只有一个实例
    msg是主线程的局部变量，对主线程可见，子线程不能访问，但是子线程通过ptr间接地访问了
    i是主线程的局部变量，对主线程可见，子线程不能访问
    myid是子线程的局部变量，每个子线程独立地拥有一个，互不干扰

    4. 线程的join操作

    这个文件是集成了很多知识点，包括线程创建、创建时候给线程传参数2种方式、线程的函数如何正确接受参数，线程静态变量、join操作
*/
```
### 信号量实现同步互斥
#### 同步的概念和四个准则
同步的概念：并发进程在一些关键点上可能需要互相等待或互通消息，这种相互制约的等待或互通消息称为进程同步。  
同步机制应遵循的准则：  
空闲让进，忙则等待，有限等待，让权等待。  
其中，前三个是必须的，实现临界区互斥机制可以不是让权等待。

信号量的两个操作：P操作、V操作  
P操作：占有，信号量减1  
V操作：释放，信号量加1

信号量初始值的设置看需求。不一定为1。  

P、V操作的具体实现是不一定的，例如P操作可以无条件减1，也可以有条件地减1。无条件减1，先减，再看信号量s是多少，是负数就阻塞；ppt提供了先看信号量是否大于0，大于0则减1，为0则阻塞。  
无条件地减1，那么信号量是负数时，绝对值就是等待资源的进程个数。  

#### 两种信号量使用场景
互斥：只允许一个进程使用，例如，闸门一次只能过一个人。  
同步：也叫计数，资源等说法，计数信号量，信号量的初始值设置为资源的个数。比如，场馆内容纳最多100人。  

#### 三种信号量应用问题
##### 生产者-消费者问题
生产者和消费者中间有一个缓冲区，缓冲区是有个数限制的，这边用到了计数信号量（并且有两个）。缓冲区同时只能有生产者放东西进去，或者消费者取东西出来，这个过程不能同时做，有个互斥信号量。

三个信号量：mutex互斥信号量，对缓冲区的互斥访问。  
slots：缓冲区槽的计数，初值n。
items：缓冲区元素的计数，初值0。  
生产者需要获取slot，释放item；消费者获取item，释放slot。
需要注意，互斥锁在内层获得和释放。
```c
/* 生产者的 */
P(&slots) // 生产者获取槽位

P(&mutex) // 访问缓冲区确保互斥
// 添加元素
V(&mutex) // 释放互斥锁

V(&items) // 宣告有元素

```
例子 因为新冠疫情影响，某博物馆限制最多可容纳100人参观，有一个出入口，该出入口一次仅允许一个人通过。参观者的活动描述如下：  
```
cobegin
参观者线程 i :
 {
 …
进门
…
参观
…
出门
…
 }
 coend
```
请添加必要的信号量和P、V操作，以实现上述过程中的互斥与同步。要求写出完整的过程，说明信号量的含义并赋值。  
解答：只有一个线程是参观者，参观者能否进门要消耗一个参观容纳名额，出入口进出是要互斥的。所以需要两个信号量。一个初值100，进门前获得，出门后释放。一个互斥信号量初值1，包裹进门和出门。  

##### 读者-写者问题（读者优先）
对于一个资源，读者只读，写者只写，读与读不需要互斥，但是写与写需要互斥。读与写之间也需要互斥。读者的优先级高于写，如果正在写，读者不会抢夺写者的资源，但是如果至少还有一个读者在读，写者都应该排队等着。

解决：需要一个互斥锁用于写资源的权限，任何写者要写，都应获取这个锁。同时，第一个进入的读者应该获取这个锁，防止写者写；最后一个离开的读者应该释放这个锁，允许写。因此需要维护一个读者数量，每个读者进入后，应该把这个量加1，离开时减1。读者修改这个量又需要同步，所以还需要一个互斥锁用于读者数量。  一共两个互斥锁。  
互斥信号量 mutex4w 用于写操作的互斥  
互斥信号量 mutex4rcnt 用于读者数量  
```c
// 写者
P(&mutex4w)
写
V(&mutex4w)

// 读者
P(&mutex4rcnt)
rcnt++;
if(rcnt==1) P(&mutex4w)
V(&mutex4rcnt)
读
P(&mutex4rcnt)
rcnt--;
if(rcnt==0) V(&mutex4w)
V(&mutex4rcnt)
```
##### 哲学家用餐问题
问题模型：n个哲学家坐圆桌吃饭，n双筷子，每两个人中间一双筷子。哲学家吃饭必须左手拿到筷子，右手也拿到筷子，才能吃饭。如果所有人都拿到右手边筷子，那么所有人的左手都拿不到筷子，就是死锁。这个问题的模型中，每一个筷子都是一个互斥资源，需要设置一个互斥信号量。  
问题解决思路：限制至多允许n-1名哲学家同时“抢”筷子。  
问题解决：每个筷子一个互斥信号量，就要有`chopsticks[n]`, 初值均为1。 设置一个允许用餐人数`sm`,初值为`n-1`，每个哲学家首先获得“用餐名额”`P(sm)`,再依次获取左手边和右手边的筷子。然后吃饭。这样保证至少一个哲学家可以同时获取左手和右手边的筷子，从而不会有死锁。  
注意：需要快速地对哲学家和筷子编号，假设哲学家的编号是`0...n-1`,筷子编号也是`0...n-1`,哲学家`i`右手边的筷子是`i`, 那么左手边的筷子编号是 **(i+n-1)%n** ,假设哲学家i左手边筷子编号i简单一点，右手边筷子就是 **(i+1)%n** .

#### 信号量控制语句执行的先后
例如语句S1先于S2执行，用信号量来保证，可以设置初值为0的信号量，S1结束后加V操作，S2前加P操作，就可以保证S1执行完后才执行S2。
#### 信号量作业题
信号量的题目，要灵活的设计信号量的初始值，和解锁时机。同时要注意信号量的P、V操作具体实现，P是有条件地减，还是无条件地减。ppt最先给出的是有条件地减。不如就记住一种无条件减、V也无条件加地操作方式。
```
P(){
  s--;
  if(s<0) 阻塞；
}
V(){
  s++;
  if(s<=0) 唤醒一个阻塞队列中的；
}
```
注意，P操作判断的是减1了之后s<0,s==0不阻塞；V操作判断的是加1了之后s<=0，意思是没加1之前，s<0,那么就有进程在阻塞等待，因此要唤醒。  
作业题设计计数型也是基于这个操作模式来的。
**要注意信号量初值的设计**，例如信号量初值设0，可以很简单地用于控制先后顺序。在作业中，初值设为0，那么第一次P操作立即阻塞，其他V直接操作又能够将其唤醒。所以就可以做出一个“阻塞开关”的作用。  
作业1.假设你有一个只有二进制信号量的操作系统，但你希望使用计数信号量。请你演示如何使用二进制信号量实现计数信号量的P_new()和V_new()操作。提示：可以使用两个二进制信号量，一个用来实现计数互斥，另一个用来实现阻塞。  
设计：整型cnt用于资源计数，初值就是资源数；mutex信号量初值1，用于实现对cnt的修改的互斥；block信号量初值0，用于实现阻塞。  
```
P_new(){
  P(mutex);
  cnt--;
  if(cnt<0) {
    V(mutex);  // 尽早释放，提高性能
    P(block);   // block初值为0，直接阻塞
  }
  else V(mutex) //其他情况也需要放锁
}
V_new(){
  P(mutex);
  cnt++;
  if(cnt<=0) {
   V(mutex)
   V(block)；  // 唤醒一个
    
  }
  else V(mutex);
}
```


### 死锁
#### 死锁的4个必要条件
互斥使用  
不可抢占  
持有和等待  
循环等待  

> 4个必要条件和死锁预防3个方法可以对应记忆 
> 互斥使用是无法避免的，因为一个资源不可共享是这个资源天生的性质。必须有互斥使用的资源才可能发生死锁，并且这个条件破坏不了；  
> 不可抢占，资源不能被剥夺。如果资源可以被剥夺当然不会有死锁，如果需要时强制回收资源，就破坏不可剥夺条件，不会出现死锁。  
> 占有并等待：如果资源一次性申请了所有需要的资源，那就不存在占有并等待的问题。就是因为不是一次性申请，而是逐步申请，才会出现死锁。如果进程一次性满足所有资源需求，就破坏占有并等待的条件，不会有死锁。  
> 循环等待：循坏等待资源时就出现了死锁，因为进程执行的顺序是随机的乱序的，所以**可能**循环等待。如果要求进程申请资源有一个顺序，就没有循环等待的可能性，从而破坏这个必要条件。  
1. 鸵鸟策略（Ostrich Approach）
概念：系统干脆忽略死锁问题，假装死锁不会发生，或者发生的概率极小，不去专门处理死锁。
优点：简单、低开销，适用于死锁发生概率很低的系统。
缺点：一旦死锁发生，系统可能陷入永久阻塞，难以恢复。
适用场景：某些嵌入式系统或低并发的场景下，死锁很少发生。
2. 死锁预防（Deadlock Prevention）
概念：通过**破坏导致死锁的四个必要条件中的一个或多个**，来防止死锁的发生。
策略：
破坏互斥条件：尽量让资源能够共享，但对于不可共享的资源，这一点无法避免。
破坏占有并等待：要求进程一次性申请所需的全部资源，或者在没有资源时释放已有资源。
破坏不可剥夺条件：允许系统在必要时强制收回资源，将其分配给其他进程。
破坏循环等待条件：对资源进行排序，进程必须按照固定顺序申请资源，避免形成循环等待链。
优点：预防死锁的发生，安全性高。
缺点：可能导致系统资源利用率低或进程的灵活性降低。
3. 死锁避免（Deadlock Avoidance）
概念：系统动态检查分配状态，**确保每次资源分配不会导致系统进入不安全状态**（即可能死锁的状态）。
常用算法：银行家算法（Banker’s Algorithm），通过判断当前的资源分配请求是否会使系统进入不安全状态来决定是否分配资源。
优点：避免系统进入死锁状态。
缺点：需要额外的计算开销，系统需要预知每个进程的资源需求，复杂性较高。  
> 注意不安全状态和死锁状态，银行家算法检查的是是否为不安全状态，不安全=可能死锁≠死锁。系统处于不安全状态，不能说处于死锁状态；只有当进程提出资源申请并且全部进入阻塞状态时，系统才处于死锁状态。  
4. 死锁检测和恢复（Deadlock Detection and Recovery）
概念：允许死锁发生，但系统会检测出死锁，并采取措施恢复系统正常运行。
死锁检测：系统通过周期性检测（如使用资源分配图）来发现死锁。
死锁恢复：
终止进程：终止死锁进程以释放资源。可以终止所有死锁进程或逐个终止直到死锁解除。
资源抢占：强制剥夺资源，让死锁中的某些进程释放资源，从而恢复系统运行。
优点：死锁处理灵活，不必预防死锁，适合并发性高的系统。
缺点：检测和恢复会导致系统开销和性能损失，可能导致数据丢失。
#### 总结
鸵鸟策略：忽视死锁，适用于低概率场景。
死锁预防：通过破坏必要条件，提前避免死锁。
死锁避免：动态判断是否进入死锁状态，常用银行家算法。
死锁检测和恢复：允许死锁发生，通过检测和恢复操作解决。


#### 死锁预防的银行家算法
两个向量： work向量和available向量
两个矩阵： 各进程已经分配到的资源allocation 和 各进程还需要的资源need

need[i] 表示进程i还需要的资源数
finish数组 finish[i]表示进程i是否可完成

available向量只有一个初始值，初始让work的初始值等于available，之后work每回合更新

用i遍历检查每个进程
在循环中，每次将work与need[i]比较，若work能够满足need[i]，那么标记进程i为能够完成，把allocation[i]加到work中，work更新为新值。
伪代码：
```c
bool FOUND;
while(1) {
    FOUND=false
    for(int i = 0; i < n; i++) {
        // 要注意，这里是伪代码，work和need[i]都是向量，其实是没有定义直接的大小比较运算和加法运算的。其意思是每一个元素都要大于或者都要做加法。
        // 所以这个代码的时间复杂度是O(m*n*n)，n是两层循环的次数是n平方，
        // m是来自 work和need[i]的长度是m
        if(!finish[i] && work >=need[i]) { // 条件判断work是否满足need[i]
            work += allocation[i];           //allocation[i]加进work 
            finish[i] = true;                // 标记可完成
            FOUND = true;

            printf("%d->",i);  // 用于输出安全序列
        }

    }
    if(!FOUND) {
        break;              // 用一个FOUND来控制每一轮是否找到一个可完成的进程
    }       // 如果有一轮未找到可完成的进程，说明要么死锁找不到，要么全部完成了
}
for(int i = 0; i < n; i++) {
    if(!finish[i]) printf("deadlock");
}
```

### 处理器调度 

#### 批处理系统
多道：内存中同时有多个程序。  
多道批处理系统：单核CPU，微观上串行，宏观上多道程序可以并发调度。  
分时操作系统：有时间片的概念。会按照时间片调度任务。

#### 调度算法
FCFS 有利于CPU繁忙型，不利于IO繁忙型作业。对长作业有利，对短作业相对不利。  

SJF平均等待时间、平均周转时间最少，但是对长作业不利，可能出现饥饿现象。  
SJF可以是抢占式，也可以是非抢占式。默认sjf是非抢占的，sjf的抢占版本也叫最短剩余作业优先SRJF。  

高响应比优先调度。解决了饥饿的问题。是fcfs和sjf的平衡，对短作业和长作业都比较友好。但是计算相应比开销大，相应比公式 (等待时间+要求服务时间)/要求服务时间。 可以记住等待时间在分子，所以等的很久的作业相应比会很高，从而不会出现饥饿现象。

时间片轮转调度算法：适合**交互**。队列是FCFS来排的，要注意队列长什么样子，不能想当然觉得是12341234轮转。  
分时-交互-时间片轮转。  响应时间和用户数、时间片长度成正比。  
时间片轮转调度算法依赖于时钟中断和时钟中断处理程序，可能时钟中断处理程序判断时间片用完，这个时钟中断处理程序结束后，就要开始进程调度。

优先级调度算法是一个概念，进程优先级可以是静态赋予的，也可以是动态调整的。具体的有多级队列反馈算法，分为不同优先级的队列，总是先在高优先级的队列调度。每个队列内部的调度算法可以不一样。**多级反馈队列调度算法能使短作业、长作业和交互作业用户都满意**。  

注意进程调度，进程调度就是从就绪态选出一个开始执行，和进程切换不一样。最初是的时候选出第一个执行的进程，也是一次调度。

##### 作业调度和进程调度的区分
如果题目中同时出现作业调度和进程调度，那么要对他们作出区分，否则课内是比较模糊的。作业到达≠作业进入内存并作为进程进行调度。哪个作业进入内存是作业调度，内存中哪个进程执行是进程调度；  要注意周转时间，是作业提交（到达）到作业完成的时间，包括了作业等待、作业在就绪队列中排队、在cpu运行和IO操作的时间总和。换言之，周转时间是完成时间-作业到达时间，不是减去进入内存时间。  

**做题的时候画二维的图来表示进程调度过程**。
#### 其他记忆内容
C那程序的存储：使用内存时分为3个段，正文段，堆段，栈段，代码和**常量（全局赋值变量）** 放在正文段，动态分配的存储区（malloc的）放堆，临时变量、实参都在栈段。进程优先级之类的是PCB的内容。  
系统动态DLL库中的系统线程，被不同的进程所调用，它们是（相同）的线程。  

## 内存管理
### 程序怎么进入内存
程序经过 编译、链接、装入三个步骤进入内存。    
程序中的内存地址，编程的时候都是相对地址，进入内存后要修改为能用的地址。这个修改地址的行为叫做重定位。   
重定位: 为执行程序而对其中出现的地址所做的修改  
重定位有三种时机：  
1. 链接的时候，就把地址改为绝对地址。后面装入的时候，装到约定好的地方。这种装入又叫绝对装入。    
2. 链接后，地址是相对地址，装入的时候，把地址改成绝对地址。这种装入叫做**可重定位装入**，或者叫**静态重定位**。一旦装入后，就不能移动程序的位置了。  
3. 装入后，地址还是相对地址，执行的时候，有一个基址寄存器，通过硬件完成地址变换，叫做**动态重定位**,**运行时重定位**，或者**动态运行时装入**。    
### 内存分配与管理方案
#### 1 连续内存分配
1. 固定分区 有内部碎片。固定的分区又可以分为等长和不等长。  
2. 变长分区/可变分区：管理空闲分区链表，记录空闲分区的起始地址和长度。当请求分配的时候，再分配。这里涉及**分区分配算法**。有外部碎片。
可变分区有产生外部碎片的可能性，于是就会有紧凑技术，（**内存紧缩技术**）  ，用来整理内存的外部碎片。于是意味着，可变分区的程序装入后可能要改变位置，那么就得采用动态重定位，不能用静态重定位。   
> 哪些存储管理可以用静态重定位？只有固定分区分配可以，可变分区、页式、段式都不可以。  
##### 可变分区分配算法
首次适配：空闲链表按照地址低到高排序，选第一个能适配的。  
最佳适配：空闲链表按大小从小到达排序，选最刚好能装的。  
最差适配：选最大的去装。

##### 内存的回收要当心合并
连续内存分配，进行回收时，要把释放的内存分区插入到空闲链表中，可能恰好和前面的空闲分区或者后面的空闲分区连着，此时要考虑合并空闲分区的问题。


#### 2 分段内存分配与管理
每个进程有一个段表，按照代码、数据等分段，适合程序员视角。  
逻辑地址格式：段号+段内偏移量组成。  
由于段与段不等长，段基址一般是一个明确的地址，不像页表存一个页号即可。并且段长度要显式地存储在段表里面。页表不需要长度，因为页长度是约定好的。       
地址翻译：逻辑地址取出段号，查段表得到基址，判断是否越界，段基址+偏移量得到物理地址。  
地址翻译可能是十进制段号和偏移给出，可能是给出十六进制地址自己取出段号和偏移，可能是给出十进制，用除法和取余数得到段号、偏移。   

有内部碎片也有外部碎片。

#### 3 分页内存分配与管理
将用户的逻辑地址空间和物理内存都划分为大小固定的页面，物理内存中的称为页框或帧，逻辑地址中的叫做页。例如4KB为页面的大小。  
有固定的地址格式，逻辑地址划分为页号和偏移，比如偏移12位。

每个进程有自己的页表（每个进程地逻辑地址空间是独立的，进程间互不干扰）。页表中存储对应物理页号，不需要存储逻辑页号，因为逻辑页号本身就是页表项的偏移量来的，不需要显式地存储。页表存储的应该连续覆盖每一个页号。因此页表会很大，从而需要多级页表来节省空间。  
##### 多级页表
每一级页表，页表本身也是恰好占一个页。规定根页表只能占用一个页。一级页表最高级。  
页表项里的项是下一级页表的页号加上一些标志位。多级页表典型的有10-10-12划分32位地址，页表项4B。  

##### TLB查询
TLB是个硬件，储存最近查过的页表项，利用了局部性。用于加速地址翻译。  
进程切换后，TLB也要切换。  

##### 页表翻译
页表翻译和段表翻译类似，地址可能十进制，可能十六进制。十六进制/二进制可以按照位划分来提取页号、偏移，十进制适合用除法、取余来获得逻辑页号和偏移量，并用公式得到物理地址。  
公式：逻辑页号 * 页长度 + 偏移量

有TLB，页表查询计算存取时间的题目，TLB查询有不同的策略：有可能TLB先查询，未命中才去内存查页表；有可能同时查TLB和内存页表，TLB命中则结束内存页表查询；这两种方式的有效存取时间不同。**要注意看**  
如果是前者，那么失败的情况是（1-命中率）*（tlb查询时间+2次内存访问时间）

地址计算：例如给定页表的物理基地址（或者虚拟基地址），求指定页号的页表项的地址，只需要用基地址+页号*页表项长度。  


#### 4 段页结合
段页结合的内存管理中，一般会有逻辑地址、线性地址、物理地址三个概念，逻辑地址经过段式翻译得到线性地址，线性地址在经过页表翻译得到物理地址。  
一个进程一个段表，每一个段配一个页表。

### 虚拟内存
#### 交换区
有一个磁盘交换空间，基于普通文件系统：windows中pagefile.sys文件，或者独立的磁盘分区swap。
#### 虚拟内存调页算法
fifo、lru、clock、最佳页面置换

**Belady异常**：增加了分配的页框数，结果缺页次数反而增加了。只有FIFO页面置换算法有这种现象。  


#### TLB查询细节
TLB是相联存储器，意思是硬件上实现，直接拿内容进行同时比较。
相联有直接相联、全相联、组相联，我们可以理解为相联总是按组的，组的大小不一样。因为所有的TLB项相联在一起开销很大，所以可能是几路作为一组相联在一起，虚拟地址要先根据其中划定的某几位tlb索引选定一个组，在这个组里面同时和每一个条目比较。这样就容易理清tlbi、tag位的划分。

#### 写时复制
父进程创建子进程后，和子进程共享物理内存。只有其中一方写的时候，才会在物理上复制这一页内存。

#### 工作集/驻留集
工作集和驻留集是页面的集合，是给进程分配的物理内存空间。
**工作集分配**：就是页面分配策略，固定分配和可变分配。

**置换策略**：置换策略也有两种，全局置换和局部置换。区别于置换算法，算法解决的是如何选出要置换的那一个；策略解决的是哪些可以被置换。局部置换就是只能换进程自己的页面，全局置换可以淘汰其他进程的页面。  

内存分配和置换策略组合只有3种，固定分配下只能局部置换。

### 记忆细节
进程在主存中彼此互不干扰运行，操作系统是通过**内存保护**来实现的。（错选了地址映射，地址映射应该不算保护的本质，如果逻辑地址共享的映射呢）  
段式内存管理没有内部碎片。页式和固定分区连续分配肯定有内部碎片。  
分页、分段内存管理，哪个提供给用户的物理地址空间更大？选不能确定，因为页表、段表本身占内存空间，不知道段表、页表哪个大。但是页表一般比段表大？   
**分段内存管理有利于程序的动态链接。**  
可重入程序通过减少对换数量改善系统性能。  
最容易产生内存碎片的动态分区分配算法是**最佳适应算法**。  

### core i7 案例
虚拟地址格式：4*9+12，页内偏移（VPO）12位，VPN有4级，每级9位。4级页表项是64位即8B的，所以每个页表512个项，每级VPN9位。  
物理地址格式：40+12，物理页号PPN40位，  


## 磁盘和IO
### IO设备的视图
IO系统给用户提供的是**文件视图**,用户是像操作文件一样操作设备的，不同的设备有对应一个设备文件。都是由open, read, write, close这几个调用。  
open通过文件名打开，返回文件描述符fd  
read和write通过**fd**来操作IO设备或文件。  

### IO系统的组成
最底层是IO硬件，然后是IO驱动程序（操作系统的底层），然后是和IO无关的操作系统，然后是系统调用接口。  
自底向上是硬件，中断处理程序，设备驱动程序，设备独立性程序，系统调用接口，用户程序  

### IO控制方式
程序查询，中断，DMA，通道

### 缓冲技术
磁盘缓存：内存中的一部分，缓存磁盘块。  
缓冲区：（cpu和io设备的缓冲区）分为单缓冲，双缓冲，环形缓冲，缓冲池。
spooling计数：独占设备改为共享设备。

### 磁盘设备
#### 磁盘的结构，扇区编址
从大到小是 柱面（磁道）、磁头（盘面）、扇区，柱面C，磁头H，扇区S。  
CHS编址：扇区号的公式 c * H * S + h * S + s  
这个公式意味着，同一个柱面连续读写，一个盘面读完，读下一个盘面，磁头不会动。  
磁盘IO时间：主要是磁头寻道时间，其次是旋转到指定扇区的时间（只能要一个平均，用半周的时间），还有传输时间。  

**磁盘读取时间的计算**：寻道时间+旋转延迟+传输时间+控制器开销等，寻道时间、旋转延迟、传输时间这三个是必不可少的。寻道时间占大部分，题目会给磁头移动时间，旋转延迟取旋转半周的时间，传输时间不大但是要注意不能遗漏。 其他开销很短，题目没说就忽略。

#### 磁盘寻道调度算法
FCFS，SSTF，SCAN，C-SCAN，C-LOOK  ，因为主要时间来自磁头寻道，参考的就是磁头移动距离。

#### 固态硬盘SSD
前面说的都是机械硬盘。固态硬盘基于闪存技术，没有机械机构，读写速度特别快。随机写比较慢。  
固态硬盘缺点：容易磨损。

## 文件系统
### 物理结构
物理结构就是连续、链式、索引三种。有的叫连续存放，连续分配，连续存储，索引分配，索引存储都是一个意思。
| 分配方式 | 优点 | 缺点 |
| --- | --- |-----|
| 连续分配 | 可以随机访问，简单快速，磁盘寻道时间也短 | 要求有连续存储空间，容易产生**磁盘碎片**。不利于文件增长扩充。 （**大量碎片，不易扩充**） |
| 链接分配 | 不要求连续存储空间，磁盘利用率高，利于扩充文件| 顺序访问，效率低。   |
| 索引分配 | 既能顺序访问，又能随机访问，查找效率高，便于删除 | 索引表本身占用存储空间  |

目录项/FCB/文件头中需要保存的信息：  
连续分配：需要保存起始盘块和盘块个数。  
链接分配：保存起始盘块。  
索引分配：保存索引块的位置。  
#### 空闲磁盘块的两种管理方式
位图、空闲链表。
### 2类具体文件系统
#### 类似ext2的索引结构
目录项：目录项存储文件名，和索引节点号。  
每个inode对应一个文件。  
#### fat的链接结构
涉及到FAT表大小的计算、FAT表存储的内容等。FAT表存储的就是簇号，每一个簇都对应fat表的一项。  
大小计算：根据磁盘块号/簇号的长度，就可以得到系统支持多少个簇，就得到了FAT表的项数。通过FAT表项数和每项长度计算，得到FAT表长度。  
目录项：FAT系统中目录项存储文件名，和起始簇号，还有其他的元信息。  
### 保护和容错
保护：通过权限位，控制不同用户的 读写执行权限。实现访问控制。  
容错：通过冗余存储提高可靠性，RAID技术。
#### RAID
RAID1：镜像存储，将相同的数据写入两个磁盘。一个磁盘故障时，数据可从另一个磁盘恢复。  
RAID5+：条带化（带来并行读写），校验（带来一个块的容错和恢复能力）  
RAID5+的细节：校验块位置是分布式存储的，每个条带的校验块位置轮换，不会固定在一个磁盘上。
校验块的生成：同一个磁盘条中，校验块来自于磁盘块异或。  
出错块的恢复：某一个块出错，用这一个条带中其他数据块和校验块异或恢复数据。  
存储效率推导： （N-1）/N  如果磁盘个数是N。  



# 组成原理2 RISC-V
## RISC-V汇编语言
先看一组C程序和对应的汇编语言
```c
int A[20];
int sum = 0;
for (int i = 0; i < 20; i++) {
    sum += A[i];
}
```
对应的汇编语言如下
```
add x9 , x8 , x0    # x8为数组A[20]的地址， 把&A[0]存在x9，因为不能动x8，x8之后可能有别的用处
add x10 , x0 , x0   # sum  初始值为0，存在寄存器x10
add x11 , x0 , x0   # i    初始值为0，存在寄存器x11
addi x13 , x0 , 20  # 20是比较的次数，需要先存在寄存器x13，因为后续要用来分支判断，但是分支语句比较只能是两个寄存器比较，比较是不能用立即数的
Loop:
    bge  x11 , x13 , Done   # 如果 i >= 20 跳转到Done。 汇编中进入循环，总是先检查循环是否结束
    lw x12 , 0(x9)          # 读取A[i]的值到x12中， x9寄存器存放的是他的地址
    add x10 , x10 , x12     # sum = sum + A[i]
    addi x9 , x9 , 4        # x9存放地址的，要加上4，4byte是一个字, 得到了 &A[i+1]
    addi x11 , x11 , 1      # i++
    j Loop                  # 无条件跳转到Loop处，形成循环
Done:
```

### RISC-V汇编语言的语法和指令
#### 指令语句的基本格式
一行汇编语言代码表示一条机器指令。每一行语句的格式都是：
```
one   two, three, four
```
依次表示操作名称、操作数1、操作数2、操作数3， 其中操作数1一般是接受运算的结果，操作数2、操作数3是参与运算的数。操作名称和三个参数之间用空格隔开，三个参数之间用逗号隔开。例如：
```
add  x1, x2, x3
```
这是表示加法运算， 和`x1=x2+x3`一个意思。
#### 汇编语言的基本元素
汇编语言中操作的对象全都是寄存器，数据储存在寄存器中，指令作用于寄存器完成运算等操作，对寄存器进行存储、读取等会和内存交流数据。因为寄存器运算快。寄存器是硬件中真实存在的，但也因此数量有限，只有32个。其中一个是x0寄存器，这个x0是硬件实现的0，的它作用就是提供0，因为0在程序中常见所以就用硬件实现，不管对x0寄存器怎么操作它都是0.除了x0以外，还有31个寄存器可用，所以数量有限。  
**x0寄存器里的值永远是0。** 写汇编语句的时候直接用x0来表示0.   
#### 加法、减法指令
加法指令叫`add`, 接上三个寄存器， 即 `add rd,rs1,rs2`。 其中rd表示register destination，就是运算结果存储到的目标寄存器， `rs1`和`rs2`中的s表示source，这两个寄存器存储的就是参与运算的两个数。  
```
add  x1,x2,x3    # 汇编语言的语句
a = b + c;       // 其他语言与之对应的语句，其中变量a 对应寄存器x1， 变量b和c对应寄存器x2和x3
```
减法指令叫`sub`，语法一样是 `sub rd,rs1,rs2`, rs1中的值减去rs2的值的结果，存放到rd寄存器里。
```
sub x3,x4,x5
d = e - f          # x3与d， e与x4， f与x5一一对应
```
如果要做多个数的混合运算，在高级语言是可以一句完成，比如 `a = b + c + d - e`， 在汇编中，每次只能两个寄存器参与运算，所以必须分几步完成。
```
a = b + c + d - e  换成RISCV汇编， bcde分别对应寄存器x1，x2，x3，x4， 运算结果a要存放在x10里

add x10,x1,x2     # 相当于 a_temp = b + c
add x10,x10,x3    # a_temp = a_temp + d
sub x10,x10-x4    # a_temp = a_temp - e

RV汇编中 #后面内容表示注释，和python一样
```
加法指令可以用来复制一个寄存器的值给另一个，比如高级语言中的赋值`b = a`, RISC-V的指令集是尽可能精简的，如果现有指令可以完成的任务，就不会引入其他指令做一样的事情.这个赋值用加法做，`add x11,x0,x10`就把x10里面的值复制到了x11里面，x0是永远存储0的特殊寄存器，就用在了这里。其他例子比如分支比较的指令，只有小于和大于等于，没有小于等于或大于。没有一个专门的按位取反指令，因为按位取反可以用和全1异或来实现。

#### 立即数
立即数就是指直接出现的常数，比如c语言语句`if(i>5)`，这个5就是一个直接出来参与运算的数字，不是存一个变量或者常量的。汇编中直接写出来的这种数字参与操作，就是立即数immediate。用立即数参与运算的操作有专门的指令，立即数加法`addi`,立即数减法没有，因为减去一个数可以用加上相反数来完成，所以只有`addi`，它的语法是`addi rd,rs,imm`,一个目标寄存器，一个参与运算的计算器，一个立即数。
```
addi rd, rs, imm
addi x3, x4, 10        # x4的值，加上10， 结果存x3
```
**立即数0**：0用的比较多，所以直接硬件上实现在了x0寄存器中，所以比如加上0就用 `add x3,x4,x0`。并且x0里的值是硬件实现的，不管怎么对x0操作都不会变。
#### 内存地址和数据读存指令
8bit是1byte，4byte是1个字。内存是以byte为单位来寻访的。而存的数据一般1个字，那么4个连续的byte存储一条数据，他们各自有地址。1个字的地址取这4个字节中最低位的来作为1个字的地址。要得到下一个字的地址，要加4位，必须是4的倍数。  
数据在内存中遵循小端模式存放，低位数据放在低位地址里，高位数据放在高位地址里。即数据位数的高低和内存地址的高低是一致的。  

从内存中加载数据到寄存器，用load系的指令。如load word指令`lw`,加载一个字，格式比如`lw x10,12(x15)`,意思是从寄存器x15存储的地址偏移12byte的地址处，取一个字存到x10寄存器。括号里面那个寄存器是存放着目标基准地址的寄存器，外面数字是从基准地址的偏移量，两个合起来就找到了要加载的对象的地址。这个内存地址所存放的数据会加载到目标寄存器。注意如果使用`lw`指令,那个偏移量肯定是4的倍数。

把寄存器的内存存到内存中指定地址，用store系的指令，`sw`表示存一个字，比如示例做完加法后，要进行存放。sw指令接的第一个寄存器，是要存放的内容的寄存器，后面是目标内存地址。格式和lw指令一样，但数据的流向是相反的。

```
int A[100];
g = h + A[3];
A[10] = g

lw x10,12(x15)    # x15存储着A数组的基地址，即指向A[0]的指针,int是4个字节，所以用lw指令，偏移量12是3个4，偏移3个元素
add x11,x12,x10   # x12 存储着h， 得数g存储到x11
sw x11,40(x15)    # x15存储着A数组及地址，偏移40就找到A[10]的基地址

数据流向：←--
lw    x10, 12(x15)

         --→
sw    x11, 40(x15)
```
加载一个byte，存储一个byte叫做`lb`和`sb`，格式与`lw`和`sw`一样。不过目标地址就没有限制是4的倍数。对于`lb`指令，有一个细节在于加载到寄存器的位置。从内存中读来的这个byte加载到寄存器的最低8bit上，并且会进行高位扩展，这一个byte中最高位会向寄存器内容的更高位扩展，更高位全部复制成这个byte的最高位。 

无符号数的加载指令。上面的`lb`指令认为操作对象是有符号数，所以`lb`指令加载后会进行高位扩展，全部复制成加载来的这个byte的最高位。`lbu`指令是加载一个无符号字节，和`lb`的不同之处就在于高位扩展的时候不是复制这八bit中的最高位，而是全部填0，当作无符号数。

#### 条件分支语句
相当于高级语言中的if语句，有几个指令，比如`beq`,`bne`,`bge`,`blt`等，格式都是 `beq reg1,reg2,L1`,操作名，两个寄存器，这两个寄存器里的值参与条件判断，最后那个L1是语句中的标记，如果条件满足，会跳转到标记处继续执行语句。b表示branch，后面两个字母代表条件， 比如beq是branch if equal，blt是branch if less than。  
beq等这些b开头的是条件跳转指令，会先对两个寄存器的值做条件判断，满足条件后会跳转，不满足条件就不跳转。形成分支的还有无条件跳转指令j，j加上一个标注， `j Lable`，就会直接跳转到Lable处，不需要条件。  

```
程序示例，f存x11，g存x12，h存x13，i存x14，j存x15
if(i==j)
    f = g + h


    bne x14, x15, Exit
    add x11, x12, x13
Exit:
```
上面这个程序判断i==j时，用g+h得到f，但是c语言用`i==j`判断，汇编指令却用bne,因为汇编总是按顺序执行每一行，所以反过来判断不相等就跳走，相等就按顺序继续执行。
```
程序示例，f存x10，g存x11，h存x12，i存x13，j存x14
if(i==j)
    f = g + h
else
    f = g - h

     bne x14, x15, Else
     add x11, x12, x13
     j Exit
Else:sub x11, x12, x13
Exit:
```
如果是if-else的语句，就得用一次无条件跳转来完成。

blt、bge、bltu、bgeu这四个是比较大小的，其中u表示把两个寄存器中的数字作为无符号数来比较大小，而blt和bge是把两个寄存器中的数字当作有符号数比较。比如`blt reg1,reg2,Lable`，意思是如果reg1的数比reg2的数小，那么跳转到Lable处继续执行。  

#### 循环语句
循环语句也是用条件分支得到的，在进入了Loop后，循环语句的最后总是用无条件跳转`j Loop`回到Loop处，为了离开循环，要有一句循环条件的检查判断，判断当循环应结束时，就直接跳转Done处离开循环。
```c
int A[20];
int sum = 0;
for (int i = 0; i < 20; i++) {
    sum += A[i];
}
```
对应的汇编语言如下
```
add x9 , x8 , x0    # x8为数组A[20]的地址， 把&A[0]存在x9，因为不能动x8，x8之后可能有别的用处
add x10 , x0 , x0   # sum  初始值为0，存在寄存器x10
add x11 , x0 , x0   # i    初始值为0，存在寄存器x11
addi x13 , x0 , 20  # 20是比较的次数，需要先存在寄存器x13，因为后续要用来分支判断，但是分支语句比较只能是两个寄存器比较，比较是不能用立即数的
Loop:
    bge  x11 , x13 , Done   # 如果 i >= 20 跳转到Done。 汇编中进入循环，总是先检查循环是否结束
    lw x12 , 0(x9)          # 读取A[i]的值到x12中， x9寄存器存放的是他的地址
    add x10 , x10 , x12     # sum = sum + A[i]
    addi x9 , x9 , 4        # x9存放地址的，要加上4，4byte是一个字, 得到了 &A[i+1]
    addi x11 , x11 , 1      # i++
    j Loop                  # 无条件跳转到Loop处，形成循环
Done:
```

#### 按位运算指令
按位与and ，或运算or，异或运算xor，逻辑左移运算sll(shift left logical),逻辑右移运算srl，算术右移sra，没有算术左移。这些运算的格式全是比如`and rd,rs1,rs2`，把rs1和rs2运算的结果存rd里。移位的话时把rs1移位rs2里的数字的次数。这几个运算都有立即数版本，只要加i就是立即数的版本，用法的变化只是第三个寄存器改成立即数，其他都没变，和add、addi完全一样。它们都是算术运算的指令。
逻辑左右移动是一律补0，算术右移会复制最高位来填充。  
#### 伪指令
一些指令不是真的专门的指令，而是其他几个指令做到的，但是这么写更利于理解。比如复制寄存器的值到另一个用mv，指定立即数存进寄存器li，不做任何事情的指令nop。
```
mv rd,rs    完全等同于 addi rd,rs,0
li rd,13    完全等同于 addi rd,x0,13
nop         完全等同于 addi x0,x0,0
```

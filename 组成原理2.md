# 组成原理2 RISC-V
## RISC-V汇编语言
先看一组C程序和对应的汇编语言
```c
int A[20];
int sum = 0;
for (int i = 0; i < 20; i++) {
    sum += A[i];
}
```
对应的汇编语言如下
```
add x9 , x8 , x0    # x8为数组A[20]的地址， 把&A[0]存在x9，因为不能动x8，x8之后可能有别的用处
add x10 , x0 , x0   # sum  初始值为0，存在寄存器x10
add x11 , x0 , x0   # i    初始值为0，存在寄存器x11
addi x13 , x0 , 20  # 20是比较的次数，需要先存在寄存器x13，因为后续要用来分支判断，但是分支语句比较只能是两个寄存器比较，比较是不能用立即数的
Loop:
    bge  x11 , x13 , Done   # 如果 i >= 20 跳转到Done。 汇编中进入循环，总是先检查循环是否结束
    lw x12 , 0(x9)          # 读取A[i]的值到x12中， x9寄存器存放的是他的地址
    add x10 , x10 , x12     # sum = sum + A[i]
    addi x9 , x9 , 4        # x9存放地址的，要加上4，4byte是一个字, 得到了 &A[i+1]
    addi x11 , x11 , 1      # i++
    j Loop                  # 无条件跳转到Loop处，形成循环
Done:
```

### RISC-V汇编语言的语法和指令
#### 指令语句的基本格式
一行汇编语言代码表示一条机器指令。每一行语句的格式都是：
```
one   two, three, four
```
依次表示操作名称、操作数1、操作数2、操作数3， 其中操作数1一般是接受运算的结果，操作数2、操作数3是参与运算的数。操作名称和三个参数之间用空格隔开，三个参数之间用逗号隔开。例如：
```
add  x1, x2, x3
```
这是表示加法运算， 和`x1=x2+x3`一个意思。
#### 汇编语言的基本元素
汇编语言中操作的对象全都是寄存器，数据储存在寄存器中，指令作用于寄存器完成运算等操作，对寄存器进行存储、读取等会和内存交流数据。因为寄存器运算快。寄存器是硬件中真实存在的，但也因此数量有限，只有32个。其中一个是x0寄存器，这个x0是硬件实现的0，的它作用就是提供0，因为0在程序中常见所以就用硬件实现，不管对x0寄存器怎么操作它都是0.除了x0以外，还有31个寄存器可用，所以数量有限。  
**x0寄存器里的值永远是0。** 写汇编语句的时候直接用x0来表示0.   
#### 加法、减法指令
加法指令叫`add`, 接上三个寄存器， 即 `add rd,rs1,rs2`。 其中rd表示register destination，就是运算结果存储到的目标寄存器， `rs1`和`rs2`中的s表示source，这两个寄存器存储的就是参与运算的两个数。  
```
add  x1,x2,x3    # 汇编语言的语句
a = b + c;       // 其他语言与之对应的语句，其中变量a 对应寄存器x1， 变量b和c对应寄存器x2和x3
```
减法指令叫`sub`，语法一样是 `sub rd,rs1,rs2`, rs1中的值减去rs2的值的结果，存放到rd寄存器里。
```
sub x3,x4,x5
d = e - f          # x3与d， e与x4， f与x5一一对应
```
如果要做多个数的混合运算，在高级语言是可以一句完成，比如 `a = b + c + d - e`， 在汇编中，每次只能两个寄存器参与运算，所以必须分几步完成。
```
a = b + c + d - e  换成RISCV汇编， bcde分别对应寄存器x1，x2，x3，x4， 运算结果a要存放在x10里

add x10,x1,x2     # 相当于 a_temp = b + c
add x10,x10,x3    # a_temp = a_temp + d
sub x10,x10-x4    # a_temp = a_temp - e

RV汇编中 #后面内容表示注释，和python一样
```
加法指令可以用来复制一个寄存器的值给另一个，比如高级语言中的赋值`b = a`, RISC-V的指令集是尽可能精简的，如果现有指令可以完成的任务，就不会引入其他指令做一样的事情.这个赋值用加法做，`add x11,x0,x10`就把x10里面的值复制到了x11里面，x0是永远存储0的特殊寄存器，就用在了这里。其他例子比如分支比较的指令，只有小于和大于等于，没有小于等于或大于。没有一个专门的按位取反指令，因为按位取反可以用和全1异或来实现。

#### 立即数
立即数就是指直接出现的常数，比如c语言语句`if(i>5)`，这个5就是一个直接出来参与运算的数字，不是存一个变量或者常量的。汇编中直接写出来的这种数字参与操作，就是立即数immediate。用立即数参与运算的操作有专门的指令，立即数加法`addi`,立即数减法没有，因为减去一个数可以用加上相反数来完成，所以只有`addi`，它的语法是`addi rd,rs,imm`,一个目标寄存器，一个参与运算的计算器，一个立即数。
```
addi rd, rs, imm
addi x3, x4, 10        # x4的值，加上10， 结果存x3
```
**立即数0**：0用的比较多，所以直接硬件上实现在了x0寄存器中，所以比如加上0就用 `add x3,x4,x0`。并且x0里的值是硬件实现的，不管怎么对x0操作都不会变。
#### 内存地址和数据读存指令
8bit是1byte，4byte是1个字。内存是以byte为单位来寻访的。而存的数据一般1个字，那么4个连续的byte存储一条数据，他们各自有地址。1个字的地址取这4个字节中最低位的来作为1个字的地址。要得到下一个字的地址，要加4位，必须是4的倍数。  
数据在内存中遵循小端模式存放，低位数据放在低位地址里，高位数据放在高位地址里。即数据位数的高低和内存地址的高低是一致的。  

从内存中加载数据到寄存器，用load系的指令。如load word指令`lw`,加载一个字，格式比如`lw x10,12(x15)`,意思是从寄存器x15存储的地址偏移12byte的地址处，取一个字存到x10寄存器。括号里面那个寄存器是存放着目标基准地址的寄存器，外面数字是从基准地址的偏移量，两个合起来就找到了要加载的对象的地址。这个内存地址所存放的数据会加载到目标寄存器。注意如果使用`lw`指令,那个偏移量肯定是4的倍数。

把寄存器的内存存到内存中指定地址，用store系的指令，`sw`表示存一个字，比如示例做完加法后，要进行存放。sw指令接的第一个寄存器，是要存放的内容的寄存器，后面是目标内存地址。格式和lw指令一样，但数据的流向是相反的。

```
int A[100];
g = h + A[3];
A[10] = g

lw x10,12(x15)    # x15存储着A数组的基地址，即指向A[0]的指针,int是4个字节，所以用lw指令，偏移量12是3个4，偏移3个元素
add x11,x12,x10   # x12 存储着h， 得数g存储到x11
sw x11,40(x15)    # x15存储着A数组及地址，偏移40就找到A[10]的基地址

数据流向：←--
lw    x10, 12(x15)

         --→
sw    x11, 40(x15)
```
加载一个byte，存储一个byte叫做`lb`和`sb`，格式与`lw`和`sw`一样。不过目标地址就没有限制是4的倍数。对于`lb`指令，有一个细节在于加载到寄存器的位置。从内存中读来的这个byte加载到寄存器的最低8bit上，并且会进行高位扩展，这一个byte中最高位会向寄存器内容的更高位扩展，更高位全部复制成这个byte的最高位。 

无符号数的加载指令。上面的`lb`指令认为操作对象是有符号数，所以`lb`指令加载后会进行高位扩展，全部复制成加载来的这个byte的最高位。`lbu`指令是加载一个无符号字节，和`lb`的不同之处就在于高位扩展的时候不是复制这八bit中的最高位，而是全部填0，当作无符号数。

例题1 使用的寄存器是32位（RV32I），若mem[x1] = 0x12000180，执行指令 lb x11, 1(x1) ，寄存器x11的数据为：______
解：先从x1偏移1字节的地址取1字节，是取了01存至x11的最低8bit，x11高位那24bit复制01的最高bit也就是0，所以x11数据为0x00000001  
例题2 使用的寄存器是32位（RV32I），若mem[x1] = 0x12000180，执行指令 lb x12, 0(x1) ，寄存器x12的数据为：______  
解：先从x1所指向的地址取1字节，是取了80存至x12的最低字节，x12的高位会复制80的最高bit，而80的最高bit是1，所以x12的高位全是1，最低7bit是0，因此x12中数据未0xFFFFFF80  
例题3 使用的寄存器是32位（RV32I），若mem[x1]=0x12000180，执行如下指令后mem[x1]的数据为：lb x12, 0(x1)  ；  sb x12, 2(x1)  
先取数据80存x12，x12的高位复制载入的字节的最高位1，x12是0xFFFFFF80，再把x12载入一个字节到x1所指地址偏移2字节的位置，sb储存的是x12的最低字节，也就是80储存到目标地址的字节去。所以80存到了x1所指地址偏2字节的位置，x1的内容变成0x12800180

#### 条件分支语句
相当于高级语言中的if语句，有几个指令，比如`beq`,`bne`,`bge`,`blt`等，格式都是 `beq reg1,reg2,L1`,操作名，两个寄存器，这两个寄存器里的值参与条件判断，最后那个L1是语句中的标记，如果条件满足，会跳转到标记处继续执行语句。b表示branch，后面两个字母代表条件， 比如beq是branch if equal，blt是branch if less than。  
beq等这些b开头的是条件跳转指令，会先对两个寄存器的值做条件判断，满足条件后会跳转，不满足条件就不跳转。形成分支的还有无条件跳转指令j，j加上一个标注， `j Lable`，就会直接跳转到Lable处，不需要条件。  

```
程序示例，f存x11，g存x12，h存x13，i存x14，j存x15
if(i==j)
    f = g + h


    bne x14, x15, Exit
    add x11, x12, x13
Exit:
```
上面这个程序判断i==j时，用g+h得到f，但是c语言用`i==j`判断，汇编指令却用bne,因为汇编总是按顺序执行每一行，所以反过来判断不相等就跳走，相等就按顺序继续执行。
```
程序示例，f存x10，g存x11，h存x12，i存x13，j存x14
if(i==j)
    f = g + h
else
    f = g - h

     bne x14, x15, Else
     add x11, x12, x13
     j Exit
Else:sub x11, x12, x13
Exit:
```
如果是if-else的语句，就得用一次无条件跳转来完成。

blt、bge、bltu、bgeu这四个是比较大小的，其中u表示把两个寄存器中的数字作为无符号数来比较大小，而blt和bge是把两个寄存器中的数字当作有符号数比较。比如`blt reg1,reg2,Lable`，意思是如果reg1的数比reg2的数小，那么跳转到Lable处继续执行。  

#### 循环语句
循环语句也是用条件分支得到的，在进入了Loop后，循环语句的最后总是用无条件跳转`j Loop`回到Loop处，为了离开循环，要有一句循环条件的检查判断，判断当循环应结束时，就直接跳转Done处离开循环。
```c
int A[20];
int sum = 0;
for (int i = 0; i < 20; i++) {
    sum += A[i];
}
```
对应的汇编语言如下
```
add x9 , x8 , x0    # x8为数组A[20]的地址， 把&A[0]存在x9，因为不能动x8，x8之后可能有别的用处
add x10 , x0 , x0   # sum  初始值为0，存在寄存器x10
add x11 , x0 , x0   # i    初始值为0，存在寄存器x11
addi x13 , x0 , 20  # 20是比较的次数，需要先存在寄存器x13，因为后续要用来分支判断，但是分支语句比较只能是两个寄存器比较，比较是不能用立即数的
Loop:
    bge  x11 , x13 , Done   # 如果 i >= 20 跳转到Done。 汇编中进入循环，总是先检查循环是否结束
    lw x12 , 0(x9)          # 读取A[i]的值到x12中， x9寄存器存放的是他的地址
    add x10 , x10 , x12     # sum = sum + A[i]
    addi x9 , x9 , 4        # x9存放地址的，要加上4，4byte是一个字, 得到了 &A[i+1]
    addi x11 , x11 , 1      # i++
    j Loop                  # 无条件跳转到Loop处，形成循环
Done:
```
有另一种控制循环的方式，上面那种是用一个寄存器存储当前迭代到的单元的地址，用一个寄存器存储当前迭代到的单元的序号用于判断循环是否结束，他们都需要增加，并且是分别增加，即各自用立即数加法取增加。下面这种循环方式用一个寄存器存储当前迭代到的单元的序号（下标），然后用一个寄存器存储当前迭代到的单元的地址，但是不是通过分别增加，而是通过下标移位算出地址的偏移量，然后用偏移量加上基地址得到当前迭代到的单元的地址，这样只做了一次立即数相加。
```
/*c语言程序*/
long long int save[100]
while (save[i]==k) i++;
对应的汇编  save的基地址存在x25，用x22存i，x24存k, long long 型的所以下面是8byte一个数据

Loop：
slli x10, x22, 3       # 8i
add x10, x10, x25      #  &save[i]
ld x11,0(x10)          # save[i]
bne x11, x24, Done     # 判断循环条件
addi x22, x22, 1       # i++
j Loop
Done:


```
#### 按位运算指令
按位与and ，或运算or，异或运算xor，逻辑左移运算sll(shift left logical),逻辑右移运算srl，算术右移sra，没有算术左移。这些运算的格式全是比如`and rd,rs1,rs2`，把rs1和rs2运算的结果存rd里。移位的话时把rs1移位rs2里的数字的次数。这几个运算都有立即数版本，只要加i就是立即数的版本，用法的变化只是第三个寄存器改成立即数，其他都没变，和add、addi完全一样。它们都是算术运算的指令。
逻辑左右移动是一律补0，算术右移会复制最高位来填充。  

例题 假设寄存器x10中存储的值为2，x11寄存器中存储的值为4，x12寄存器中存储的值为5，请书写RISC-V代码计算 $(2\times 8-4)+5\times4$，结果存储在x10中。
这题放这里意思是，如果去想要用2和4制造一个8出来，那就不对，虽然可以用乘法指令，但是如果要求不能再用别的临时寄存器储存8就不行。应该注意到，2乘8这一步要用移位来完成，因为二进制里面左移位就是乘2。把2移位3次就实现了2乘8。  
#### 伪指令
一些指令不是真的专门的指令，而是其他几个指令做到的，但是这么写更利于理解。比如复制寄存器的值到另一个用mv，指定立即数存进寄存器li，不做任何事情的指令nop。
```
mv rd,rs    完全等同于 addi rd,rs,0
li rd,13    完全等同于 addi rd,x0,13
nop         完全等同于 addi x0,x0,0
```
#### 汇编语言中的函数调用
汇编语言的语句是写死在一个地方的，函数的调用是通过标注跳转来完成的，从主程序跳到函数的语句处，然后函数的代码执行完，又跳回函数的入口那从下一句开始继续执行。为了完成这个跳转又跳回的过程，汇编指令也是每句有一个地址的，要先把函数的入口处的地址存到一个寄存器中，即返回地址ra，然后跳转到函数之后，通过ra的值才能知道要跳转回哪里继续执行。第二，不管是在主程序还是在调用函数内，是在运行caller还是在callee，汇编语言不存在为调用函数专门创建的“本地变量”，而是所有整个过程共享那31个寄存器，这就会出现下一层函数调用时要使用上一层函数正在使用的寄存器的情况，这种时候就得用到栈，把寄存器作为上一层函数正在存放的值先存到内存里，让下一层函数先用这个寄存器，下一层函数调用结束后，再从栈取回这个值，还给上一层函数用。函数调用就是处理好跳转和寄存器使用权的问题。 
##### 寄存器使用习惯
返回地址的寄存器ra：即寄存器x1，专门在函数调用的时候存储返回地址，跳出函数回到上一层的时候就要用到。  
函数使用的参数的寄存器a0-a7：即寄存器x10到x17，类似于形参，其中x10和x11常用于返回值。
##### 函数调用时跳转的指令
指令本身都是32bit的数据，一个程序的所有指令存储在内存里面，该程序的每一条指令都有一个地址，并且相邻的两条之间地址差4，（因为一条指令1个字，很显然的）。程序执行到调用函数时，会跳转到内存另一个位置的这个函数，函数运行后又要跳回运行的那一句的下一句开始继续执行代码。因此，我们要知道调用函数的那一句（即跳转到函数，比如函数标记Sum， j Sum 无条件跳转到Sum的代码位置）的地址是什么，然后加4得到下一个指令的地址，存到ra寄存器中，函数运行的最后会有一个指令跳转到ra所存的地址处。这样就实现了caller和callee之间的跳转。跳转到寄存器所存地址的指令是`jr`, 用法是`jr ra`，即跳转到ra所存的地址。jr是jump reg的意思，按寄存器内容跳转。
代码示例：
```
/*已有c函数*/
int sum(int a, int b){
    return a + b;
}
/*c语言执行程序的某处,x,y已经定义好*/
sun(x,y);

x，y对应s0和s1，对应的代码，前面数字是示意程序的每句指令的地址

1000  mv  a0, s0
1004  mv  a1, s1            # 这两句相当于传参，把x和y对应传形参a和b，函数里面用的变量是a和b
1008  addi  ra, x0, 1016    # 这一句发生在跳转到函数之前，要先记录返回地址，函数返回后继续运行的位置是跳往函数的下一句  
1012  j  sum                # 跳到标注sum处
1016   ...
...
2000 sum： add a0, a0, a1   
2004 jr  ra                 # 跳转回原来的程序

```
上面用j、ra和jr完成了指令的跳转，用一句`addi  ra, x0, 1016`来存储返回地址到ra，再调用`j sum`,可以用 `jal`指令jump and link，只需要跟函数所在位置的标注，他会自动把ra存储好，不需要人为来一句存储返回地址。jal和jr配合，可以自动实现来回跳转。而`ret`又是`jr ra`更简单的伪指令。
此外，跳转真正的指令只有jal和jalr，而j、jr、ret都是伪指令。

##### 函数调用时的栈操作
在进行函数调用时，有一些寄存器可能被caller和callee都用，就要用栈先储存，callee用完后还原，caller再继续用。有些寄存器的栈操作在caller中进行，有些寄存器的栈操作在callee中进行，这是按照一个已有的习惯进行的。  
栈是定义在内存中的一个部分，程序可以用寄存器sp即x2，stack pointer来操作栈。栈指针指示着栈顶元素的地址。栈是倒着内存地址存的，就是Push操作时减小栈顶位置，存入元素，Pop操作时增大栈顶位置，即栈指针是往高地址移动。就是说栈顶的地址是小的，栈底反而是大地址。用的时候也是倒过来用。下面一个示例，s0和s1是习惯上由callee来负责存栈的两个寄存器。
```
int leaf(int g, int h, int i, int j) {
    int f;
    f = (g + h) - (i + j);
    return f
}

g,h,i,j分别对应a0,a1,a2,a3, s1是可以使用的临时寄存器，s0和s1使用需要存栈，以不影响其他地方使用。对应的汇编语句

addi sp, sp, -8         # 要存放s0和s1的数据，所以栈先准备2个字的空间，栈是倒过来用所以-8
sw s0, 4(sp)
sw s1, 0(sp)            # 这两句将s0和s1压栈，先是偏移4字节，再是偏移0字节
add s0, a0, a1          # g+h先存着
add s1, a2, a3          # i+j再存着
sub a0, s0, s1          # 结果f存入a0返回即可，这边可以用a0来返回这个会和函数调用处配合好
lw s1, 0(sp)
lw s0, 4(sp)             
addi sp, sp, 8          # 这三句完成退栈操作，和头三三局刚好是对称的，后进先出的关系
jr ra                   # 返回
```
上面这个是因为函数调用的过程中，可能寄存器不够用，需要用到s0和s1来做一个临时的寄存器使用，但是这两个不是专门的函数参数寄存器，可能其他地方也用到，不能干扰其他地方使用，因此要做一个栈存储。  
当函数嵌套调用时，也需要使用到栈操作，是因为caller和callee都用的a0到a7这些参数寄存器，并且caller调用下一层函数，也要存储自己调用callee的ra，所以a0到a7、ra这些寄存器都是多次使用因此要存栈给内层函数先用，用完出栈外层函数再继续用。而ra、a0到a7这些习惯上caller来存栈。   
下面示例是一个叫做sumSqueare的函数，他里面会调用一次mult函数，而他们两个函数都会用a0和a1寄存器，而mult的返回值就存在a0寄存器，于是在sumSquare这个caller中要维护几个寄存器的存栈出栈。
```
sumSquare(int x , int y) {
    return mult(x, x) + y;      // mult(x,y)返回x乘y的值
}

对应的汇编，某处代码的sumSquare标记处,因为sumSquare用到a0，a1分别存储x和y，但a0和a1也要给mult用，mult返回在a0可以继续用，但是a1就得存栈再读取，并且ra肯定要存栈,所以ra和a1要存栈耗费两字的内存
sumSquare：
addi sp, sp, -8        # 准备两个字的栈空间
sw ra, 4(sp)           # 存储返回地址
sw a1, 0(sp)           # 将a1和ra的内容压栈中，这句存储y
mv a1, a0              # 这句相当于传参数，a0和a1都要用做mult函数的形参，a0是已经载入好了，a1此前还是本来的y，要先载入成x给mult用
jal mult               # 调用mult函数,下一行的时候，a0就是mult返回的结果了
lw a1, 0(sp)           # 取回本来y的值回到a1
add a0, a0, a1         # 返回值是 mult(x,x) + y
lw ra, 4(sp)           # 取回ra的值，即sunSquare的返回地址
addi sp, sp, 8         # 把栈空间释放
jr ra                  # 返回调用sunSquare的地方

mult： # mult在别的地方，不用管
```
内存是线性的，栈内存是内存的一个区域，栈底在内存最高处，并向低地址使用内存空间。同时还有个堆内存heap，从低往上使用内存空间。如果他们相遇，那就内存用满了。  
##### 指令合集
```
算数或逻辑运算
add
sub
sll
sla
srl
or
and
xor
用立即数的算数或逻辑运算
addi
slli
slai
srli
ori
andi
xori
数据存取
lw
sw
lb
sb
lbu
分支跳转
beq
bne
bge
blt
bltu
bgeu
jal    
jalr
伪指令
j
jr
mv
li
```
#### 递归函数一例
递归函数其实是大量函数嵌套调用，而且是嵌套自身。但实际上写汇编的递归函数，写的时候其实和c语言一样，在fact里面要调用作为callee的fact的时候，不要一直去想它们是同一个函数，而是可以把被调用的callee就当作是另一个已经实现好的函数，能够完成他要做的功能，在caller里面调用前处理好参数和返回地址的存栈，并且在`jal ra,fact`这句调用函数的语句后边处理好退栈，再正常完成返回值的计算，正常返回，做完过一遍发现已经实现好了。这跟高级语言构思递归函数是完全一样的，写完结构也一样的。
```c
/*递归实现阶乘函数*/
int fact(int n) {
    if(n < 1) {
        return 1;
    }
    else {
        return n * fact(n-1);
    }
}
```
对应的汇编,x10用于存放n,也存放返回值
```
fact:          # 标记先写
#因为fact函数本身是为了嵌套调用fact，那fact本身就是个caller，因此要用栈储存返回地址和参数寄存器x10
addi x5, x10, -1         # 这句和下面那句bge是配合起来使用，意思就是判断n是否是0，如果n是0了，那么不会跳转到else。
bge x5, x0, Else         # 比较n-1和0的值，如果n-1小于0，不会跳转else。 这两行完全可以换成 blt x0, x10, Else，从而不需要x5 
# 接下来写的是n<1,即n=0，x10里边是0的处理方式,我们要返回1,而x10本身也是返回值的寄存器
addi x10,x0,1   # x10恢复成1
jr ra           # 返回
Else:
# else的情况，就需要嵌套调用，因此要存栈
addi sp, sp, -8   # 先做出栈空间
sw ra, 4(sp)  # 把返回地址保存栈里
sw x10, 0(sp) # 把x10现在的值保存到栈里
# 现在可以进行函数调用，应该先做“载入参数”，也就是x10要减1，即传给callee的参数
addi x10, x10, -1       #x10直接减1就完成了传参
jal ra,fact                #调用函数，虽然调用的还是fact，但这里可以先当他不是同一个
#然后就当被调用的fact运行完了，会返回到下一句，继续做下一句的事情。因为x10作为返回值，因此此时x10里面就是被调用的fact返回的值
#被调用的函数调用完，这时候应该把退栈还原，但是x10已经存了上一级的返回值，而现在又要把我们这一个caller的x10取回来，那必然要通过另一个寄存器来帮忙
add x6, x10, x0       # 把现在的x10，即callee返回来的值，先放到x6暂存
lw x10, 0(sp)         # 取回x10
lw ra, 4(sp)          # 取回ra
addi sp, sp, 8        # 把栈空间释放掉 ，这三句完成退栈
mul x10, x10, x6      # 这句就是把 n和fact(n-1)的值相乘，同时这个值继续存储到x10，即返回值寄存器中，这样他返回后，他的caller在x10中会得到他的返回值
jr ra


```
ppt里面写法思路是每次调用fact，不管会不会再有嵌套调用，总是先把自己的返回地址和参数存栈，（先存栈再说），然后一样的进行条件判断，并且每次返回前都会伴随出栈。其中，作为整个递归过程的那次、也就是n=0的、没有跳转else的那一次返回，因为存栈的值根本不被需要，所以无需取回值，而是直接把栈空间释放了即可。
```
fact:
# 进入函数，作为caller，先存栈了再说
addi sp, sp, -8    # 做出栈空间
sw x1, 4(sp)       # 返回地址存栈
sw x10, 0(sp)      # 寄存器x10里边参数n的存栈
# 函数需要进行判断一个n的值进行一个条件判断，如果n = 0，或者n>=1, 那可以用 n-1>=0作为判断内容
addi x5, x10, -1   # 做出n-1存寄存器x5里面
bge x5, x0, else   # 条件判断 n-1>=0,如果符合，应该走else,如果不符合，就往下顺序执行
# 往下顺序执行的，是n==0的情况，即整个递归调用过程的出口，应该返回1.两件事：返回值为1， 退栈并返回。之所以退栈，是因为开始的时候不管有没有嵌套调用都先存了栈，
# 因此，现在每次返回，不管是否真的有了嵌套调用，都要必须把栈空间还回去。这里的情况因为没有真的做一个嵌套调用，所以不需要从栈里面取回原值，只需要释放空间。
addi x10, x0, 1    # 寄存器x10的值为1，这句就是li x10,1 ， x10现在是作为存一个返回值，所以设定为1
addi sp, sp, 8     # 把栈空间还回去，但不必把栈里面的值取回来，因为没有被改变也不需要用到
jalr x0, 0(x1)     # 返回，用jalr指令
# 这个返回完，就是if(n < 1) {...}全写完了
else:
# 下面写else情况，因为进入函数的时候不分情况一律先把返回地址和参数存栈了，因此可以直接开始递归调用
addi x10, x10, -1   # 相当于传参
jal x1, fact        # 递归地调用fact函数，运行fact(n-1)
# 写完上面那句，不想上面那句会怎么走，而是想说fact(n-1)运行完了，返回到了这里，现在x10里面就是fact(n-1)的值
# 我们只需要把这个值和栈里边退出来的n乘一下，返回(返回肯定必须伴随着退栈)就行, 下面就返回
add x6, x10, x0     # x10 赋值给x6， 即mv x6,x10， 因为x10存储上一步的返回值，但接下来他又要回归到参数n的身份,所以fact(n-1)的返回值要x6来存
lw x10, 0(sp)       # 把x10的值退栈
lw x1, 4(sp)        # 把返回地址退栈, 和入栈那边是对称的
addi sp, sp, 8      # 释放栈空间
mul x10, x10, x6    # n和fact(n-1)的值相乘，同时这个值作为返回值要存到x10里面。其实上面把x10当作返回值的时候，x10能存返回值的逻辑还没写出来，到这才写出来
# 此时返回值已经存好，栈也退了，直接返回即可
jalr x0, 0(x1)      # 返回





```



## RISC-V指令格式
riscV指令其实都是32位数字，尤其注意与rv32、rv64无关，那个是寄存器能储存的位数，而指令是在不同的riscV中都通用的。
> 这边说指令都是32位数字，其实有一点例外，那就是B型指令寻址的时候是以2字节做单位来寻址，那是考虑了16位的压缩指令。

在理解指令的基本格式上，riscV指令的基本格式，可以把32位划分成 7-5-5-3-5-7的区块，在不同类型格式中，每个区块大致相同，略有差异。  
第2个“7”： 最低的7位，一定是opcode区。  
第1个“5”： rs2，在没有rs2的指令中，可以用来存立即数。  
第2个“5”： rs1，只有在j型指令和U型指令（只有这两类没有rs1），也拿来存放立即数。  
第3个“5”： rd， 在没有rd的指令中，用来存立即数。
第1个“7”： funct7或者立即数。  
3bit区： funct3的区，但是U型和J型指令是没有的，而是存立即数。  

### R型指令
R型指令是指有rs1、rs2、rd，从两个源寄存器获取数据进行算数或逻辑运算，又把计算结果存入目标寄存器的指令。这类指令opcode一般都是0110011，有funct7、funct3。格式上没什么特殊，从高到低严格按照7-5-5-3-5-7划分，依次是funct7、rs2、rs1、funct3、rd、opcode。  

### I型指令
I型指令是指R型指令中，其中一个运算数不来自寄存器而是使用立即数的变体，比如有add变成addi，or变成ori。也就是有rs1，有rd，没有rs2而是有一个立即数。I型指令的过程是从源寄存器获取数据，和立即数进行算数或逻辑运算，把结果存入目标寄存器。这类指令在格式上，没有funct7和rs2，把高12位用来存放一个12位立即数。格式上，一般是把前面的7-5合并，从高到低按照12-5-3-5-7划分，依次是 12位立即数、rs1、funct3、rd、opcode。 但是三个移位指令，srai、srli、slli是特殊的，它们仍然可以看作按照7-5-5-3-5-7的划分，funct7是有指定的数字，第一个5是立即数，也就是他们移位要移的位数。移位的位数5位就能表示了，因为最多就移31位。  
Load类的指令也是I型指令。load指令需要一个基地址存储器，一个立即数做偏移量，一个目标寄存器rd。因此load指令刚好是I型的，12位偏移量放在立即数区域，rs1是基地址，rd是目标寄存器。在硬件的实现中，立即数和rs1的数据经过相加（ALU里做了加法）得到目标内存地址，然后从目标内存地址读出数据写回rd。

### S型指令
S型指令是store类的指令，要求有rs1和rs2，和一个立即数的偏移量，没有rd。rs1是提供基地址，立即数是偏移量，rs2提供要存储到内存的数据。因此，指令的高7位和第三个“5”可以用来存放立即数。因此，S型的格式可以分为7-5-5-3-5-7，依次是offset[11:5],rs2，rs1，funct3，offset[4:0],opcode。

S型指令和Load类的指令，funct3的部分用于区分存取的是字，还是字节，还是半字。  

### B型指令
B型指令是branch开头的分支跳转指令。他需要寄存器rs1和rs2，用于分支条件判断。再要一个立即数，用于计算跳转到的位置。B型指令的执行过程中，rs1和rs2的数据读出来做分支判断。PC和立即数在ALU中相加得到新的PC，实现跳转。没有目标寄存器。因此，在格式上，在保持rs2、rs1、funct3和opcode不懂的情况下，其他可以拿来存放12位立即数表示PC的偏移量。这和S型指令一样，但是存放的方式不一样。  
> 设计CPU数据通路的时候就明白，cpu自己知道PC是多少，可以直接取用PC寄存器的值，所以指令上不用体现PC。
#### B型指令的立即数范围
B型指令的立即数表示PC的偏移量，执行时，用PC和立即数相加，得到新的PC。由于这个立即数12位，能表示的范围是 $-2^{11}$到 $2^{11}-1$，那B型指令计算的是PC，是用来指示指令的，和其他访问数据存储器的地址不同，访问指令的地址肯定是要指向指令的开头，因此理论可以按照1个字作为单位来跳转。12位数能表示的范围是 $-2^{11}$到 $2^{11}-1$，但是单位可以是字节，也可以是2个字节，可以是4个字节。作为访问指令的指针，我们要尽可能访问多的范围，就应该按照4个字节当单位来访问。但实际上又要考虑16位压缩指令的存在，因此实际上的实现中，是按照2个字节为单位来访问的。  
**实际上能够指示的字节数**： $-2^{11}$到 $2^{11}-1$ 乘以 2字节， 就是 -4096到 4094，单位（字节）。  
**实际上能够指示的指令数**： $-2^{11}$到 $2^{11}-1$ 乘以 2字节， 一个指令4个字节，我们把单位换成4字节。 -1024 到 1023， 单位（4个字节）。  

那如果是理想状态，假设以32位为单位来访问指令存储器， 那么是  $-2^{11}$到 $2^{11}-1$ 乘以 4字节，实际上达到了 $-2^{13}$到 $2^{13}-4$ 单位（字节）的范围。 因此，关键是把握12位立即数能表示的数位范围是固定的，但是根据我们实现时可以使用不一样的单位，通过转换单位，来求对应要求的单位下范围是多少。

#### B型指令立即数储存
因为B型指令立即数是12位，以2字节作为单位来寻址。因此实际上，我们存储的是32位立即数的【12：1】这12位，而最低的第0位肯定是0。所以在B型指令中，存储Imm[12:1],那安排是Imm【10：5】和Imm【4：1】尽量和S型指令那样对齐，而Imm【12】就放在最高位，Imm【11】的位置被顶了，就放到S型中Imm【0】的地方。所以B型指令的格式可以看作是7-5-5-3-5-7，依次是 立即数、rs2、rs1、funct3、立即数、opcode， 细分可以看作是1-6-5-5-3-4-1-7，依次是Imm【12】，Imm【10：5】，rs2，rs1，funct3，Imm【4：1】，Imm【11】，opcode。 

### U型指令
U型指令包括lui和auipc两条指令，lui是加载高20位长立即数，这个指令显然只有20位立即数和目的寄存器，没有源寄存器。auipc是把长立即数和pc的值相加，存入rd中，PC的值可以让cpu直接从PC寄存器中取到，因此也只需要rd寄存器。因此，U型指令没有rs1，没有rs2，也没有funct3，只有opcode和rd。这两个占去12位，剩下20位刚好全用来存放立即数。因此指令格式就是分为 20-5-7，依次是立即数Imm【31：12】、rd、opcode。  
### J型指令
J型指令只有一条就是jal指令。jal指令是需要一个目的寄存器rd，一个地址偏移量的立即数。把PC+4的值存入rd寄存器中，然后把PC更新成PC+offset，来完成跳转。因此，jal指令需要rd，需要立即数。指令格式其实上是和U型指令类似的。但是J型指令的立即数是给指令存储器的寻址，所以访问指令的偏移量，应该是和B型指令一样，以2字节作为单位。立即数最低位是0不存，存放Imm【20：1】，为了尽可能对齐，也是特意安排了立即数的存放顺序，可以分成 1-10-1-8-5-7的划分，依次是Imm【20】，Imm【10：1】，Imm【11】，Imm【19：12】，rd，opcode。 

### 指令格式的总结
指令格式中，B型指令和J型指令存放的立即数是PC相对寻址的偏移量，这两个是对指令存储器的寻址，因此它们以2字节做单位，省略第0位来存储，因此它们的存储顺序为了和其他的尽可能对齐，打乱了顺序来储存。但他们总是把最高位放在指令的最高位，这样就方便了立即数的符号扩展，符号扩展可以总是把最高位拿去复制。**这两个指令的寻址方式是PC相对寻址**。

S型和I型中的Load的指令，存放的立即数也是用来访存，但它们是数据存储器的地址，以字节为单位，他们是和rs1储存的基地址做一个加法，然后用来指示访问的地址。**这个寻址方式叫做基址或偏移寻址**  。

jalr指令是I型指令，rs1存基地址，立即数作偏移量，【rs1】+imm的值设置给pc，同时本来的pc+4会存入rd。它其实上是访问指令存储器的，但是他已经是I型指令，没办法再实现以2字节位单位寻址了，就让立即数以字节为单位。这样能访问的范围就少了。  



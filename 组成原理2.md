# 组成原理2 RISC-V
## RISC-V汇编语言
先看一组C程序和对应的汇编语言
```c
int A[20];
int sum = 0;
for (int i = 0; i < 20; i++) {
    sum += A[i];
}
```
对应的汇编语言如下
```
add x9 , x8 , x0    # x8为数组A[20]的地址， 把&A[0]存在x9，因为不能动x8，x8之后可能有别的用处
add x10 , x0 , x0   # sum  初始值为0，存在寄存器x10
add x11 , x0 , x0   # i    初始值为0，存在寄存器x11
addi x13 , x0 , 20  # 20是比较的次数，需要先存在寄存器x13，因为后续要用来分支判断，但是分支语句比较只能是两个寄存器比较，比较是不能用立即数的
Loop:
    bge  x11 , x13 , Done   # 如果 i >= 20 跳转到Done。 汇编中进入循环，总是先检查循环是否结束
    lw x12 , 0(x9)          # 读取A[i]的值到x12中， x9寄存器存放的是他的地址
    add x10 , x10 , x12     # sum = sum + A[i]
    addi x9 , x9 , 4        # x9存放地址的，要加上4，4byte是一个字, 得到了 &A[i+1]
    addi x11 , x11 , 1      # i++
    j Loop                  # 无条件跳转到Loop处，形成循环
Done:
```

### RISC-V汇编语言的语法和指令
#### 指令语句的基本格式
一行汇编语言代码表示一条机器指令。每一行语句的格式都是：
```
one   two, three, four
```
依次表示操作名称、操作数1、操作数2、操作数3， 其中操作数1一般是接受运算的结果，操作数2、操作数3是参与运算的数。操作名称和三个参数之间用空格隔开，三个参数之间用逗号隔开。例如：
```
add  x1, x2, x3
```
这是表示加法运算， 和`x1=x2+x3`一个意思。
#### 汇编语言的基本元素
汇编语言中操作的对象全都是寄存器，数据储存在寄存器中，指令作用于寄存器完成运算等操作，对寄存器进行存储、读取等会和内存交流数据。因为寄存器运算快。寄存器是硬件中真实存在的，但也因此数量有限，只有32个。其中一个是x0寄存器，这个x0是硬件实现的0，的它作用就是提供0，因为0在程序中常见所以就用硬件实现，不管对x0寄存器怎么操作它都是0.除了x0以外，还有31个寄存器可用，所以数量有限。  
**x0寄存器里的值永远是0。** 写汇编语句的时候直接用x0来表示0.   
#### 加法、减法指令
加法指令叫`add`, 接上三个寄存器， 即 `add rd,rs1,rs2`。 其中rd表示register destination，就是运算结果存储到的目标寄存器， `rs1`和`rs2`中的s表示source，这两个寄存器存储的就是参与运算的两个数。  
```
add  x1,x2,x3    # 汇编语言的语句
a = b + c;       // 其他语言与之对应的语句，其中变量a 对应寄存器x1， 变量b和c对应寄存器x2和x3
```
减法指令叫`sub`，语法一样是 `sub rd,rs1,rs2`, rs1中的值减去rs2的值的结果，存放到rd寄存器里。
```
sub x3,x4,x5
d = e - f          # x3与d， e与x4， f与x5一一对应
```
如果要做多个数的混合运算，在高级语言是可以一句完成，比如 `a = b + c + d - e`， 在汇编中，每次只能两个寄存器参与运算，所以必须分几步完成。
```
a = b + c + d - e  换成RISCV汇编， bcde分别对应寄存器x1，x2，x3，x4， 运算结果a要存放在x10里

add x10,x1,x2     # 相当于 a_temp = b + c
add x10,x10,x3    # a_temp = a_temp + d
sub x10,x10-x4    # a_temp = a_temp - e

RV汇编中 #后面内容表示注释，和python一样
```
加法指令可以用来复制一个寄存器的值给另一个，比如高级语言中的赋值`b = a`, RISC-V的指令集是尽可能精简的，如果现有指令可以完成的任务，就不会引入其他指令做一样的事情.这个赋值用加法做，`add x11,x0,x10`就把x10里面的值复制到了x11里面，x0是永远存储0的特殊寄存器，就用在了这里。其他例子比如分支比较的指令，只有小于和大于等于，没有小于等于或大于。没有一个专门的按位取反指令，因为按位取反可以用和全1异或来实现。

#### 立即数
立即数就是指直接出现的常数，比如c语言语句`if(i>5)`，这个5就是一个直接出来参与运算的数字，不是存一个变量或者常量的。汇编中直接写出来的这种数字参与操作，就是立即数immediate。用立即数参与运算的操作有专门的指令，立即数加法`addi`,立即数减法没有，因为减去一个数可以用加上相反数来完成，所以只有`addi`，它的语法是`addi rd,rs,imm`,一个目标寄存器，一个参与运算的计算器，一个立即数。
```
addi rd, rs, imm
addi x3, x4, 10        # x4的值，加上10， 结果存x3
```
**立即数0**：0用的比较多，所以直接硬件上实现在了x0寄存器中，所以比如加上0就用 `add x3,x4,x0`。并且x0里的值是硬件实现的，不管怎么对x0操作都不会变。
#### 内存地址和数据读存指令
8bit是1byte，4byte是1个字。内存是以byte为单位来寻访的。而存的数据一般1个字，那么4个连续的byte存储一条数据，他们各自有地址。1个字的地址取这4个字节中最低位的来作为1个字的地址。要得到下一个字的地址，要加4位，必须是4的倍数。  
数据在内存中遵循小端模式存放，低位数据放在低位地址里，高位数据放在高位地址里。即数据位数的高低和内存地址的高低是一致的。  

从内存中加载数据到寄存器，用load系的指令。如load word指令`lw`,加载一个字，格式比如`lw x10,12(x15)`,意思是从寄存器x15存储的地址偏移12byte的地址处，取一个字存到x10寄存器。括号里面那个寄存器是存放着目标基准地址的寄存器，外面数字是从基准地址的偏移量，两个合起来就找到了要加载的对象的地址。这个内存地址所存放的数据会加载到目标寄存器。注意如果使用`lw`指令,那个偏移量肯定是4的倍数。

把寄存器的内存存到内存中指定地址，用store系的指令，`sw`表示存一个字，比如示例做完加法后，要进行存放。sw指令接的第一个寄存器，是要存放的内容的寄存器，后面是目标内存地址。格式和lw指令一样，但数据的流向是相反的。

```
int A[100];
g = h + A[3];
A[10] = g

lw x10,12(x15)    # x15存储着A数组的基地址，即指向A[0]的指针,int是4个字节，所以用lw指令，偏移量12是3个4，偏移3个元素
add x11,x12,x10   # x12 存储着h， 得数g存储到x11
sw x11,40(x15)    # x15存储着A数组及地址，偏移40就找到A[10]的基地址

数据流向：←--
lw    x10, 12(x15)

         --→
sw    x11, 40(x15)
```
加载一个byte，存储一个byte叫做`lb`和`sb`，格式与`lw`和`sw`一样。不过目标地址就没有限制是4的倍数。对于`lb`指令，有一个细节在于加载到寄存器的位置。从内存中读来的这个byte加载到寄存器的最低8bit上，并且会进行高位扩展，这一个byte中最高位会向寄存器内容的更高位扩展，更高位全部复制成这个byte的最高位。 

无符号数的加载指令。上面的`lb`指令认为操作对象是有符号数，所以`lb`指令加载后会进行高位扩展，全部复制成加载来的这个byte的最高位。`lbu`指令是加载一个无符号字节，和`lb`的不同之处就在于高位扩展的时候不是复制这八bit中的最高位，而是全部填0，当作无符号数。

#### 条件分支语句
相当于高级语言中的if语句，有几个指令，比如`beq`,`bne`,`bge`,`blt`等，格式都是 `beq reg1,reg2,L1`,操作名，两个寄存器，这两个寄存器里的值参与条件判断，最后那个L1是语句中的标记，如果条件满足，会跳转到标记处继续执行语句。b表示branch，后面两个字母代表条件， 比如beq是branch if equal，blt是branch if less than。  
beq等这些b开头的是条件跳转指令，会先对两个寄存器的值做条件判断，满足条件后会跳转，不满足条件就不跳转。形成分支的还有无条件跳转指令j，j加上一个标注， `j Lable`，就会直接跳转到Lable处，不需要条件。  

```
程序示例，f存x11，g存x12，h存x13，i存x14，j存x15
if(i==j)
    f = g + h


    bne x14, x15, Exit
    add x11, x12, x13
Exit:
```
上面这个程序判断i==j时，用g+h得到f，但是c语言用`i==j`判断，汇编指令却用bne,因为汇编总是按顺序执行每一行，所以反过来判断不相等就跳走，相等就按顺序继续执行。
```
程序示例，f存x10，g存x11，h存x12，i存x13，j存x14
if(i==j)
    f = g + h
else
    f = g - h

     bne x14, x15, Else
     add x11, x12, x13
     j Exit
Else:sub x11, x12, x13
Exit:
```
如果是if-else的语句，就得用一次无条件跳转来完成。

blt、bge、bltu、bgeu这四个是比较大小的，其中u表示把两个寄存器中的数字作为无符号数来比较大小，而blt和bge是把两个寄存器中的数字当作有符号数比较。比如`blt reg1,reg2,Lable`，意思是如果reg1的数比reg2的数小，那么跳转到Lable处继续执行。  

#### 循环语句
循环语句也是用条件分支得到的，在进入了Loop后，循环语句的最后总是用无条件跳转`j Loop`回到Loop处，为了离开循环，要有一句循环条件的检查判断，判断当循环应结束时，就直接跳转Done处离开循环。
```c
int A[20];
int sum = 0;
for (int i = 0; i < 20; i++) {
    sum += A[i];
}
```
对应的汇编语言如下
```
add x9 , x8 , x0    # x8为数组A[20]的地址， 把&A[0]存在x9，因为不能动x8，x8之后可能有别的用处
add x10 , x0 , x0   # sum  初始值为0，存在寄存器x10
add x11 , x0 , x0   # i    初始值为0，存在寄存器x11
addi x13 , x0 , 20  # 20是比较的次数，需要先存在寄存器x13，因为后续要用来分支判断，但是分支语句比较只能是两个寄存器比较，比较是不能用立即数的
Loop:
    bge  x11 , x13 , Done   # 如果 i >= 20 跳转到Done。 汇编中进入循环，总是先检查循环是否结束
    lw x12 , 0(x9)          # 读取A[i]的值到x12中， x9寄存器存放的是他的地址
    add x10 , x10 , x12     # sum = sum + A[i]
    addi x9 , x9 , 4        # x9存放地址的，要加上4，4byte是一个字, 得到了 &A[i+1]
    addi x11 , x11 , 1      # i++
    j Loop                  # 无条件跳转到Loop处，形成循环
Done:
```

#### 按位运算指令
按位与and ，或运算or，异或运算xor，逻辑左移运算sll(shift left logical),逻辑右移运算srl，算术右移sra，没有算术左移。这些运算的格式全是比如`and rd,rs1,rs2`，把rs1和rs2运算的结果存rd里。移位的话时把rs1移位rs2里的数字的次数。这几个运算都有立即数版本，只要加i就是立即数的版本，用法的变化只是第三个寄存器改成立即数，其他都没变，和add、addi完全一样。它们都是算术运算的指令。
逻辑左右移动是一律补0，算术右移会复制最高位来填充。  
#### 伪指令
一些指令不是真的专门的指令，而是其他几个指令做到的，但是这么写更利于理解。比如复制寄存器的值到另一个用mv，指定立即数存进寄存器li，不做任何事情的指令nop。
```
mv rd,rs    完全等同于 addi rd,rs,0
li rd,13    完全等同于 addi rd,x0,13
nop         完全等同于 addi x0,x0,0
```
#### 汇编语言中的函数调用
汇编语言的语句是写死在一个地方的，函数的调用是通过标注跳转来完成的，从主程序跳到函数的语句处，然后函数的代码执行完，又跳回函数的入口那从下一句开始继续执行。为了完成这个跳转又跳回的过程，汇编指令也是每句有一个地址的，要先把函数的入口处的地址存到一个寄存器中，即返回地址ra，然后跳转到函数之后，通过ra的值才能知道要跳转回哪里继续执行。第二，不管是在主程序还是在调用函数内，是在运行caller还是在callee，汇编语言不存在为调用函数专门创建的“本地变量”，而是所有整个过程共享那31个寄存器，这就会出现下一层函数调用时要使用上一层函数正在使用的寄存器的情况，这种时候就得用到栈，把寄存器作为上一层函数正在存放的值先存到内存里，让下一层函数先用这个寄存器，下一层函数调用结束后，再从栈取回这个值，还给上一层函数用。函数调用就是处理好跳转和寄存器使用权的问题。 
##### 寄存器使用习惯
返回地址的寄存器ra：即寄存器x1，专门在函数调用的时候存储返回地址，跳出函数回到上一层的时候就要用到。  
函数使用的参数的寄存器a0-a7：即寄存器x10到x17，类似于形参，其中x10和x11常用于返回值。
##### 函数调用时跳转的指令
指令本身都是32bit的数据，一个程序的所有指令存储在内存里面，该程序的每一条指令都有一个地址，并且相邻的两条之间地址差4，（因为一条指令1个字，很显然的）。程序执行到调用函数时，会跳转到内存另一个位置的这个函数，函数运行后又要跳回运行的那一句的下一句开始继续执行代码。因此，我们要知道调用函数的那一句（即跳转到函数，比如函数标记Sum， j Sum 无条件跳转到Sum的代码位置）的地址是什么，然后加4得到下一个指令的地址，存到ra寄存器中，函数运行的最后会有一个指令跳转到ra所存的地址处。这样就实现了caller和callee之间的跳转。跳转到寄存器所存地址的指令是`jr`, 用法是`jr ra`，即跳转到ra所存的地址。jr是jump reg的意思，按寄存器内容跳转。
代码示例：
```
/*已有c函数*/
int sum(int a, int b){
    return a + b;
}
/*c语言执行程序的某处,x,y已经定义好*/
sun(x,y);

x，y对应s0和s1，对应的代码，前面数字是示意程序的每句指令的地址

1000  mv  a0, s0
1004  mv  a1, s1            # 这两句相当于传参，把x和y对应传形参a和b，函数里面用的变量是a和b
1008  addi  ra, x0, 1016    # 这一句发生在跳转到函数之前，要先记录返回地址，函数返回后继续运行的位置是跳往函数的下一句  
1012  j  sum                # 跳到标注sum处
1016   ...
...
2000 sum： add a0, a0, a1   
2004 jr  ra                 # 跳转回原来的程序

```
上面用j、ra和jr完成了指令的跳转，用一句`addi  ra, x0, 1016`来存储返回地址到ra，再调用`j sum`,可以用 `jal`指令jump and link，只需要跟函数所在位置的标注，他会自动把ra存储好，不需要人为来一句存储返回地址。jal和jr配合，可以自动实现来回跳转。而`ret`又是`jr ra`更简单的伪指令。
此外，跳转真正的指令只有jal和jalr，而j、jr、ret都是伪指令。

##### 函数调用时的栈操作





![image](https://github.com/changdick/kqtj/assets/111953773/a5d5924b-b29c-47e5-a359-7500e4b71721)## 数字的表示(原码，反码，补码)
### 原码
将一个二进制整数用原码来表示，只需在该二进制数前面加上1位，这1位就是表示符号，0表示正，1表示负号。  
将一个二进制的小数用源码表示，方法是一样的，把0或者1放在小数点左边。  

例1 x原码是1.0011，  则x=-0.0011.  
例2 x原码是11100，   则x=-1100.  
例3 x原码是0.1101，  则x=0.1101.  
例4 求x=0 的原码，   如果是小数表示， +0的原码是0.0000，-0的原码是1.0000  如果是整数，00000和10000.

### 反码
因为原码做运算不方便，所以想到了反码。反码的规则是，如果是二进制正整数，就添上一个0在前面，其实和原码一样。如果是二进制负整数，那就是把它正数部分先表示成机器码，再反转每一位。就得到了反码。

例1 x的反码是11110， 则x=-0001   （先反转回来是0，0001，说明数字是0001，看反码第一位是1，说明是负的）
例2 求0的反码    ＋0是00000 ， -0是11111

### 补码
因为反码的0有两种表示，所以把反码表示方法的负数部分全部加1，这样就只有全0的码表示0，并且全1的码表示-1，就得到了补码。  
从一个正整数真值得到其补码的办法： 就是二进制数，前面加一位0.  
从一个负整数真值得到其补码的办法： 先得到它的正数补码，然后每一位取反，然后再加上1.  
从一个补码得到真值的办法：如果这个补码头一位是0，那就直接看这个二进制数是多少。  
如果补码的头一位是1，得到真值的办法： 把负数取补码的方法逆过来操作一遍，先减去1，然后每一位取反，然后得到二进制数，然后记得加负号。  

如果补码的头一位是1，得到真值的办法：直接把这个补码每一位反转，然后再加上1，再得到二进制数，再加上负号。这样也得到了真值，用这种方法，就使得负数求补码和负数的补码求真值两个互逆的过程用一样的操作：即反转，再加上1.

如果补码的头一位是1，得到真值的另一种办法：直接看补码计算，得到十进制整数。例如补码是11011，计算的方法就是 $1\times -(2)^4 + 1\times 2^3 + 0\times 2^2 +1\times 2^1 + 1\times 2^0 = -5$

例1 x的补码是1,1110 ， x是 -0010。  
例2 x=-70,  求它的补码    先把x二进制表示， x = -1000110,  那么x的补码为 1,0111010.  
例3 x=-0.1110  求补码    x的补码为 1.0010   (先看0.1110的补码表示就是0.1110，把它反转后最低位加1即可)  
例4 x=0.0000   求补码   x的补码就是0.0000， 补码中实现了0的表示只有一个  
例5 x=-1.0000  求补码   1.0000取反是0.1111，加1又得到1.0000， -1.0000的补码表示就是1.0000.  这个好理解，1.0000作为补码，看补码求真值的方法三，补码的最高位是取负号的，那就直接正好是-1。 如果是5位的补码表示，能表示的范围是0,0001到0,1111即1到15共15个正数，00000表示0， 1,0000到1,1111即-16到-1共16个负数，可以表示的负数比正数多了一个。而反码表示中，可以表示的负数和正数一样多，因为反码中11111和00000都表示0。 这例中的-1.0000在补码中可以表示，但是在反码中表示不了。 因为它正好是补码中最高位1能拉低到的最小的数。

机器数会比本来的二进制数多一位最高位，当作符号位。正数变成机器数，原码、反码、补码是一样的，三种码制的差别在于0和负数的表示不同。


### 移码
因为补码在做比较大小的时候不方便，就设想让全0的码表示最小的数，这样真值的大小关系和机器码的大小关系一致，就得到了移码。把补码加上10000000(头一位是1，后面全是0)就得到了移码。移码的特点就是10000000(头一位是1，后面全是0)总是表示0.

### 浮点数表示
二进制数值、定点数、浮点数、定点机内机器数、浮点机内机器数。数值位、符号位，这几个概念要分清。  
二进制数值，就是把数字写作二进制，正号负号就正常写。如 -0.1101，1100，第一位不是符号位。  
定点数，就是头一位作为符号位使用，用0表示+，用1表示-得到的数，不是机器码，而是把符号用符号位来表示，数值仍保持不动得到的。整数顶点机、小数顶点机存储就是这样的数字。对于整数，会多加一个符号位。对于小数，本来就约定了小数点，只是小数点左边成为了符号位，比如本来是-0.1100,定点数就是1.1100 。  
浮点数，就类似于科学计数法。把数字写成 $2^j \times S$ ,其中j是阶码，题目中用m表示其数值位数。S是尾数，题目中用n表示其数值位数。浮点数是约定好，一段用来存储阶码，一段用来存储尾数，对于一种约定好的表示方法，能表示的数字是有个范围的。
#### 浮点数的规格化
浮点数写出来是 $2^{+101} \times +0.0001$这种形式，这就是没有规格化的。规格化的浮点数，尾数部分小数点右边的第一个数位应该是有效数字。这个有效要根据浮点数的形式灵活判断，如果浮点数已经写成把正负号换成了数符的形式，那么肯定要看到小数点右边第一个是1才算规格化。如果浮点数已经写成了补码，那么尾数看到0.0或者1.1都是没有规格化，补码要求负数看到1.0，即小数点左右两个数字不同。如果浮点数写成反码，那要看到0.1或者1.0才算规格化。总之，看规格化的思想是尾数不能出现位置上的浪费。  
浮点数规格化的数学定义： 如果尾数所表示的数字绝对值在 $[\frac{1}{2},1)$之间，就算是规格化的。但是-1和 $-\frac{1}{2}$是特例，负二分之一就是1.1000(这是原码，或者定点数),但是其补码是1.10000,是不规格化的。 -1只有补码，补码是1.0000,是规格化的。 
#### 浮点数的表示精度与范围
浮点数阶码的数值位数决定范围， 尾数的数值位数决定了精度。  
浮点数表示的范围，是不要求规格化的。因此对一种约定好的浮点数表示法，可以求出四个界：最大正数，最小正数，最大负数，最小负数。例如m=4,n=10,即阶码4位数值加1个符号位，尾数10位数值加1个符号位，能够表示的最大正数 $2^{+1111}\times +0.1111111111$(10个1)即 $2^{15}\times (1-2^{-10})$,能够表示的最小正数 $2^{-15}\times 0.0000000001$ 即 $2^{-15}\times 2^{-10}$，注意这里这个最小正数不是规格化浮点数。

例题1 设机器数字长为 24 位，欲表示±3万的十进制数，试问在保证数的最大精度的前提下，除阶符、数符各取1位外，阶码、尾数各取几位？  
因为 $2^{15}$是三万多，15写成二进制阶码，数值位要4位， 所以4位给阶码，剩下的18位给尾数。于是精度最大，并且范围足够。  

例题2 设 m = 4，n = 10，r = 2，求尾数规格化后的浮点数表示范围.
因为要求浮点数是被规格化过的，所以和上面的求浮点数的表示范围并不一样。  
最大正数 $2^{15}\times 0.11...1$, 最小正数 $2^{-15}\times 0.10...0$， 最大负数 $2^{-15}\times -0.10...0$, 最小负数 $2^{15}\times -0.11...1$。

例3 将 $+\frac{19}{128}$写成二进制定点数、浮点数及在定点机和浮点机中的机器数形式。其中数值部分均取 10 位，数符取 1 位，浮点数阶码取 5 位（含1位阶符）。
 这一类题的分母肯定是2的几次方，这种数可以把分子写成二进制形式，然后乘2的次幂就直接左右移实现。  
 二进制定点数： 先写作二进制数，是 $10011\times 2^{-7} = 0.0010011$,补成题目要求的10位数值， 即 0.0010011000 。  
 浮点数： 浮点数应当规格化，并且数值位数按照题目要求，不要求把正负号改成数符，就是 $2^{-0010}\times 0.1001100000$  写$2^{-10}\times 0.1001100000$就行了
 定点机中机器数：由于是正数，肯定就和上面定点数表示一样了0.0010011000。  
 浮点机中机器数：1,0010;0.1001100000   
 **注意：机器数要按照原码、补码、反码分别写，上面的答案是不完整**  
定点机中机器数：由于是正数，肯定原码、补码、反码就都和上面定点数表示一样了0.0010011000。  
 浮点机中机器数：原码1,0010;0.1001100000， 补码 11110;0.1001100000   反码11101；0.1001100000  
 
例4 将 -58 表示成二进制定点数和浮点数，并写出它在定点机和浮点机中的三种机器数及阶码为移码、尾数为补码的形式（其他要求同上例）。  
先写二进制形式就是 $-111010$, 由于题目要求数值10位，所以二进制定点数就是-0000111010。定点机中机器数正负号才改成数符，原码10000111010, 反码是正58的原码全部取反，或者说符号位是1，数值部分从原本的数(或者从原码)取反，反码11111000101， 补码是1;1111000110. 浮点数表示是 $2^{+6} \times -0.11101 = 2^{+110}\times -0.11101 =- 2^{110}\times 0.1110100000 $, 做成机器数，原码是0,0110;1.1110110000 反码0,0110;1.0001001111 补码 0,0110;10001010000. 阶码采用移码，尾数采用补码,阶码就要从本来的加上10000，最后是所以 10110；10001010000。  
二进制定点数：-0000111010   
二进制浮点数： $- 2^{110}\times 0.1110100000 $  
定点机中机器数 原码10000111010  反码11111000101 补码是11111000110  
浮点机中机器数 原码是0,0110;1.1110100000  反码0,0110;1.0001011111   补码 0,0110;10001100000  阶码采用移码，尾数采用补码10110；10001100000   

例5 写出对应下图所示的浮点数的补码形式。设 n = 10，m = 4，阶符、数符各取1位。   
> 图片显示了浮点数表示的最大正数、最小正数、最大负数、最小负数四个界。在最小正数和最大负数之间的数字无法表示，称为下溢，在该区间内数字都是机器0. 超过了最大正数的数字无法表示，比最小负数还小的无法表示，这两个称为上溢。注意，只要m和n确定，这四个数就是确定的，因为他们都是由m和n来定义。比如最小负数是 $2^{-(2^m-1)} \times (1-2^{-n})$ . 意思就是阶码数值位m是4，那么4能表示到的就是到-15和+15，虽然补码可以到-16，但是阶码最小就是 $2^{-(2^m-1)}$

注意这个是不要求把浮点数规格化的。 $m=4$ 就说明阶码的极限是15和-15，  
最大正数是 $2^{15} \times 0.1...1=(0.1...1)\times 2^{1111}$,      对应的补码 $0111101111111111$ 。   
最小正数 $2^{-15} \times 0.0..01 = (0.0...01)\times 2^{-1111}$,   对应的补码 $1000100000000001$ 。    
最大负数 $2^{-15}\times -0.0...01 = -(0.0...01)\times 2^{-1111}$ ,对应的补码 $1000111111111111$ 。   
最小负数 $2^{15}\times -0.1...1=-(0.1...1)\times 2^{1111}$        对应的补码 $0111110000000001$，   
